
<script>
const modules = {}
const include = path => modules[path];

modules['src/libs/observable/Observable.js'] = (() => {
  const module = { exports: {} };
  class Observable {
  constructor(value) {
    // Maybe this can cause an id collision of two observables created almost at the same time
    this._id = `${Math.random()}${+new Date()}`;
    this._value = value;
  }
  emit() {
    window.dispatchEvent(
      new CustomEvent(this._id, {
        detail: this._value,
      })
    );
  }
  get id() {
    return this._id;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    // Maybe this should do a deep compare in case value is an object?
    if (value === this._value) return;
    this._value = value;
    this.emit();
  }
}

module.exports = Observable;

  return module.exports;
})();

modules['src/libs/simpleHTML/SimpleHTML.js'] = (() => {
  const module = { exports: {} };
  const flatten = (items) => {
  const flat = [];

  items.forEach((item) => {
    if (Array.isArray(item)) {
      flat.push(...flatten(item));
    } else {
      flat.push(item);
    }
  });

  return flat;
};

const html = (elementType, getProps, children) => {
  const element = document.createElement(elementType);

  // Assign props
  if (typeof getProps === 'function') {
    Object.assign(element, getProps());
  } else {
    Object.assign(element, getProps);
  }

  // Append children
  element.append(...flatten(children).filter(Boolean));

  element.update = () => {
    // We update the props only if they are provided as a function. Otherwise they are static.
    if (typeof getProps === 'function') {
      if (element.setSelectionRange && !element.type === 'number') {
        const { selectionStart, selectionEnd } = element;
        Object.assign(element, getProps());
        element.setSelectionRange(selectionStart, selectionEnd);
      } else {
        Object.assign(element, getProps());
      }
    }

    Array.from(element.childNodes).forEach((childNode) => {
      // We check that the parent node exists because a previous sibling might
      // be a logic element which has unmounted a later element
      if (typeof childNode.update === 'function' && childNode.parentNode) {
        childNode.update();
      }
    });
  };
  return element;
};

const createContentsContainer = () => {
  const element = Object.assign(document.createElement('div'), {
    style: 'display: contents;',
  });
  return element;
};

const Each = (getArray, mappingFunction) => {
  const logicElement = createContentsContainer();
  let array = getArray();
  const childNodes = flatten(
    array.map((_, i) =>
      mappingFunction(
        () => getArray()[i],
        () => i,
        getArray
      )
    )
  );

  logicElement.append(...childNodes);

  logicElement.update = () => {
    const newArray = getArray();

    if (newArray.length === array.length) {
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
      return;
    }

    // If some elements should be added
    if (newArray.length > array.length) {
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });

      const newChildNodes = flatten(
        newArray.slice(array.length).map((_, _i) => {
          const i = _i + array.length;
          return mappingFunction(
            () => getArray()[i],
            () => i,
            getArray
          );
        })
      );

      logicElement.append(...newChildNodes);

      array = newArray;
      return;
    }

    // If some elements should be removed
    if (newArray.length < array.length) {
      // Even if we already have nodes which can be updated to match the new
      // child nodes, we need to see how many nodes we should keep, since each
      // item in the array can potentially be mapped to several nodes.
      const newChildNodes = flatten(
        newArray.map((_, i) =>
          mappingFunction(
            () => getArray()[i],
            () => i,
            getArray
          )
        )
      );

      // Remove superfluous nodes
      const childrenToBeRemoved = Array.from(logicElement.childNodes).slice(
        newChildNodes.length
      );
      childrenToBeRemoved.forEach((childNodeToBeRemoved) => {
        logicElement.removeChild(childNodeToBeRemoved);
      });

      // Update variables
      array = newArray;

      // Update current child nodes
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
    }
  };

  return logicElement;
};

const If = (getCondition, getThenChildNodes, getElseChildNodes = () => []) => {
  const logicElement = createContentsContainer();
  let condition = getCondition();
  const childNodes = condition
    ? flatten(getThenChildNodes()).filter(Boolean)
    : flatten(getElseChildNodes()).filter(Boolean);

  logicElement.append(...childNodes);

  logicElement.update = () => {
    if (condition && getCondition()) {
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
      return;
    }
    if (!condition && getCondition()) {
      condition = true;
      const thenChildNodes = flatten(getThenChildNodes()).filter(Boolean);
      // Remove the old children
      logicElement.innerHTML = '';

      // Add the new children after the logic element
      logicElement.append(...thenChildNodes);
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
      return;
    }
    if (condition && !getCondition()) {
      condition = false;
      const elseChildNodes = flatten(getElseChildNodes()).filter(Boolean);
      // Remove the old children
      logicElement.innerHTML = '';

      // Add the new children
      logicElement.append(...elseChildNodes);
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
      return;
    }
    Array.from(logicElement.childNodes).forEach((childNode) => {
      if (typeof childNode.update === 'function') {
        childNode.update();
      }
    });
  };
  return logicElement;
};

module.exports = {
  html,
  Each,
  If,
};

  return module.exports;
})();

modules['src/components/fadeIn/FadeIn.js'] = (() => {
  const module = { exports: {} };
  const { html } = include('src/libs/simpleHTML/SimpleHTML.js');

const FadeIn = (getProps, children) => {
  let opacity = 0;

  const element = html(
    'div',
    () => ({
      style: `opacity: ${opacity};
              transition: 0.25s;`,
    }),
    children
  );

  setTimeout(() => {
    opacity = 1;
    element.update();
  });

  return element;
};

module.exports = FadeIn;

  return module.exports;
})();

modules['src/libs/simpleRouter/SimpleRouter.js'] = (() => {
  const module = { exports: {} };
  function SimpleRouter(routes) {
  /**
   * @param {string} routes
   */
  this.setRoutes = function (routes) {
    Object.entries(routes).forEach(([route, title]) => {
      this.routes[route] = route;
      this.titles[route] = title;
      if (route === '/') {
        this.routes[''] = route;
        this.titles[''] = title;
      }
    });
    this.syncWithHash();
  };
  SimpleRouter.getTokens = function (hash) {
    return hash
      .split('/')
      .filter(Boolean)
      .filter((element) => element !== '#')
      .filter((element) => element !== '#!');
  };
  /**
   * @param {string} token
   * @returns {boolean}
   */
  SimpleRouter.isParameterRouteToken = function (token) {
    if (
      token.indexOf('<') !== 0 ||
      !token.slice(2, -4).includes(':') ||
      token.indexOf('>') !== token.length - 1
    ) {
      return false;
    }
    const [parameter, type] = token
      .slice(token.indexOf('<') + 1, token.indexOf('>'))
      .split(':');

    if (!['int', 'string', 'number'].includes(type)) {
      return false;
    }
    return true;
  };
  SimpleRouter.appendTokenToHash = function (hash, token) {
    return `${hash}/${token}`;
  };
  SimpleRouter.parseParameterRouteToken = function (token) {
    const [parameter, type] = token
      .slice(token.indexOf('<') + 1, token.indexOf('>'))
      .split(':');
    return {
      parameter,
      type,
    };
  };
  // (hash: string, route: string) => false | { [key: string]: number | string }
  SimpleRouter.getMatch = function (hash, route) {
    const hashTokens = SimpleRouter.getTokens(hash);
    const routeTokens = SimpleRouter.getTokens(route);
    const params = {};
    let reconstructedHash = '#!';
    if (hashTokens.length !== routeTokens.length) return false;
    for (let i of Object.keys(hashTokens)) {
      const hashToken = hashTokens[i];
      const routeToken = routeTokens[i];
      if (SimpleRouter.isParameterRouteToken(routeToken)) {
        const { parameter, type } = SimpleRouter.parseParameterRouteToken(
          routeToken
        );
        if (type === 'int') {
          if (!Router.isInt(hashToken)) return false;
          params[parameter] = parseInt(hashToken);
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        } else if (type === 'number' && !Router.isNumber(hasToken)) {
          if (!Router.isNumber(hashToken)) return false;
          params[parameter] = Number(hashToken);
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        } else if (type === 'string') {
          params[parameter] = hashToken;
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        }
      } else {
        if (hashToken !== routeToken) return false;
        reconstructedHash = SimpleRouter.appendTokenToHash(
          reconstructedHash,
          hashToken
        );
      }
    }
    return { params, reconstructedHash };
  };
  SimpleRouter.getRouteAndParamsFromHash = function (hash, routes) {
    for (let route of Object.keys(routes)) {
      const match = SimpleRouter.getMatch(hash, route);
      if (match) {
        const { params, reconstructedHash } = match;
        return { route, params, reconstructedHash };
      }
    }
    return { route: '', params: {}, reconstructedHash: '' };
  };
  /**
   * @param {Object.<string, number | string>} params
   */
  this.setParams = function (params) {
    this.params = params;
    // Todo: Maybe dispatch some kind of event
  };
  this.setCurrentRoute = function (route) {
    this.currentRoute = route;
  };
  this.setCurrentTitle = function (title) {
    this.currentTitle = title;
  };
  SimpleRouter.removeHash = function () {
    return history.replaceState(null, null, ' ');
  };
  this.syncWithHash = function () {
    const { hash } = location;
    const {
      route,
      params,
      reconstructedHash,
    } = SimpleRouter.getRouteAndParamsFromHash(hash, this.routes);
    this.setParams(params);
    this.setCurrentRoute(this.routes[route]);
    this.setCurrentTitle(this.titles[route]);
    if (reconstructedHash === '#!') {
      SimpleRouter.removeHash();
    } else {
      history.replaceState(undefined, undefined, reconstructedHash);
    }
    document.title = this.currentTitle;
  };
  this.params = {};
  this.currentRoute = '';
  this.routes = {};
  this.titles = {};
  this.hashChangeListeners = [];
  this.setRoutes(routes);
  window.addEventListener('hashchange', () => {
    this.syncWithHash();
    this.callHashChangeListeners();
  });
  /**
   * @param {string} route
   * One of the registered routes, without hashbang
   */
  this.navigateTo = (route) => {
    location.hash = `#!${route}`;
  };

  this.refresh = () => this.syncWithHash();

  // @possiblyNumber: string
  SimpleRouter.isNumber = function (possiblyNumber) {
    return !isNaN(Number(possiblyNumber));
  };
  SimpleRouter.isInt = function (possiblyInt) {
    return (
      SimpleRouter.isNumber(possiblyInt) &&
      parseInt(possiblyInt) === Number(possiblyInt)
    );
  };
  this.addHashChangeListener = (callback) => {
    this.hashChangeListeners.push(callback);
    this.callHashChangeListeners();
  };
  this.callHashChangeListeners = () => {
    this.hashChangeListeners.forEach((hashChangeListener) =>
      hashChangeListener({
        params: this.params,
        currentRoute: this.currentRoute,
      })
    );
  };
  this.getParams = () => this.params;
  this.getCurrentTitle = () => this.currentTitle;
  SimpleRouter.isProp = (propsOrChild) =>
    !(propsOrChild instanceof HTMLElement || typeof propsOrChild === 'string');
}

module.exports = SimpleRouter;

  return module.exports;
})();

modules['src/router/Router.js'] = (() => {
  const module = { exports: {} };
  const SimpleRouter = include('src/libs/simpleRouter/SimpleRouter.js');

const router = new SimpleRouter({
  '/': 'Gremlint - Query formatter',
  '/style-guide': 'Gremlint - Style guide',
});

const getCurrentRoute = () => router.currentRoute;
const addHashChangeListener = (hashChangeListener) => {
  router.addHashChangeListener(hashChangeListener);
};

module.exports = {
  getCurrentRoute,
  addHashChangeListener,
};

  return module.exports;
})();

modules['src/libs/simpleColorPalette/SimpleColorPalette.js'] = (() => {
  const module = { exports: {} };
  const TextColor = 'slategray';
const InputTextColor = 'darkslategray';
const HighlightedTextColor = 'darkslategray';
const DisabledTextColor = 'lightgray';
const HighlightColor = 'yellowgreen';
const White = 'white';

module.exports = {
  TextColor,
  InputTextColor,
  HighlightedTextColor,
  DisabledTextColor,
  HighlightColor,
  White,
};

  return module.exports;
})();

modules['src/components/loadingAnimation/LoadingAnimation.js'] = (() => {
  const module = { exports: {} };
  const { html } = include('src/libs/simpleHTML/SimpleHTML.js');
const { White } = include('src/libs/simpleColorPalette/SimpleColorPalette.js');

const LoadingAnimation = (getProps) => {
  let loadingCompletion = 0;
  let coloredImageHasLoaded = false;
  let grayscaleImageHasLoaded = false;
  const getOnLoadingComplete = () => getProps().onLoadingComplete;
  const setColoredImageHasLoaded = () => {
    if (!coloredImageHasLoaded) {
      coloredImageHasLoaded = true;
      element.update();
    }
  };
  const setGrayscaleImageHasLoaded = () => {
    if (!grayscaleImageHasLoaded) {
      grayscaleImageHasLoaded = true;
      element.update();
    }
  };

  const element = html(
    'div',
    () => ({
      style: `position: fixed;
              background: ${White};
              top: 0;
              right: 0;
              bottom: 0;
              left: 0;
              z-index: 2;
              `,
    }),
    [
      html(
        'div',
        () => ({
          style: `height: 100%; width: 100%; position: absolute; bottom: calc(50vh - 25vmin);`,
        }),
        [
          html(
            'img',
            () => ({
              src:
                'https://gremlint.com/wp-content/uploads/2020/07/Lowpoly-Gremlin-with-Text-Grayscale-1080x1080-1.png',
              style: `opacity: ${
                grayscaleImageHasLoaded && loadingCompletion !== 100 ? 1 : 0
              };
                      transition: 0.25s;
                      height: 50vmin;
                      width: 50vmin;
                      display: block;
                      margin: auto;
                      position: absolute;
                      bottom: 0;
                      left: 50%;
                      transform:
                      translate(-50%, 0);`,
              onload: setGrayscaleImageHasLoaded,
            }),
            []
          ),
        ]
      ),
      html(
        'div',
        () => ({
          style: `overflow: hidden;
          height: ${loadingCompletion / 2}vmin;
          width: 100%; position: absolute;
          bottom: calc(50vh - 25vmin);`,
        }),
        [
          html(
            'img',
            () => ({
              src:
                'https://gremlint.com/wp-content/uploads/2020/07/Lowpoly-Gremlin-with-Text-1080x1080-1.png',
              style: `opacity: ${loadingCompletion !== 100 ? 1 : 0};
                      transition: 0.25s;
                      height: 50vmin;
                      width: 50vmin;
                      display: block;
                      margin: auto;
                      position: absolute;
                      bottom: 0;
                      left: 50%;
                      transform: translate(-50%, 0);`,
              onload: setColoredImageHasLoaded,
            }),
            []
          ),
        ]
      ),
    ]
  );
  const load = () => {
    setTimeout(
      () => {
        if (loadingCompletion < 100) {
          if (coloredImageHasLoaded && grayscaleImageHasLoaded) {
            loadingCompletion++;
            element.update();
          }
          load();
        } else {
          element.update();
          setTimeout(getOnLoadingComplete(), 250);
        }
      },
      loadingCompletion === 0 ? 250 : 10
    );
  };
  load();
  return element;
};

module.exports = LoadingAnimation;

  return module.exports;
})();

modules['src/views/styleGuide/rules/Rules.js'] = (() => {
  const module = { exports: {} };
  const rules = [
  {
    title: 'Break long queries into multiple lines',
    explanation: `What is considered too long depends on your application.

When breaking the query, not all parts of the traversal have to be broken up. First, divide the query into logical groups, based on which steps belong naturally together. For instance, every set of steps which end with an as()-step often belong together, as they together form a new essential step in the query.
    
If anoymous traversals are passed as arguments to another step, like a filter()-step, and it's causing the line to be too long, first split the line at the commas. Only if the traversal arguments are still too long, consider splitting them further.`,
    example: `// Good (80 characters max width)
g.V().hasLabel('person').where(outE("created").count().is(P.gte(2))).count()
    
// Good (50 characters max width)
g.V().
  hasLabel('person').
  where(outE("created").count().is(P.gte(2))).
  count()
    
// Good (30 characters max width)
g.V().
  hasLabel('person').
  where(
    outE("created").
    count().
    is(P.gte(2))).
  count()`,
  },
  {
    title: 'Use soft tabs (spaces) for indentation',
    explanation:
      'This ensures that your code looks the same for anyone, regardless of their text editor settings.',
    example: `// Bad - indented using hard tabs
g.V().
  hasLabel('person').as('person').
  properties('location').as('location').
  select('person','location').
    by('name').
    by(valueMap())
    
// Good - indented using spaces
g.V().
∙∙hasLabel('person').as('person').
∙∙properties('location').as('location').
∙∙select('person','location').
∙∙∙∙by('name').
∙∙∙∙by(valueMap())`,
  },
  {
    title: 'Use two spaces for indentation',
    explanation:
      'Two spaces makes the intent of the indent clear, but does not waste too much space. Of course, more spaces are allowed when indenting from an already indented block of code.',
    example: `// Bad - Indented using four spaces
g.V().
    hasLabel('person').as('person').
    properties('location').as('location').
    select('person','location').
        by('name').
        by(valueMap())

// Good - Indented using two spaces
g.V().
  hasLabel('person').as('person').
  properties('location').as('location').
  select('person','location').
    by('name').
    by(valueMap())`,
  },
  {
    title: 'Use indents wisely',
    explanation: `No newline should ever have the same indent as the line starting with the traversal source g.

Use indents when the step in the new line is a modulator of a previous line.

Use indents when the content in the new line is an argument of a previous step.

If multiple anonymous traversals are passed as arguments to a function, each newline which is not the first step of the traversal should be indented to make it more clear where the distinction between each argument goes. If this is the case, but the newline would already be indented because the step in the content in the new line is the argument of a previous step, there is no need to double-indent.

Don't be tempted to add extra indentation to vertically align a step with a step in a previous line.`,
    example: `// Bad - No newline should have the same indent as the line starting with the traversal source g
g.V().
group().
by().
by(bothE().count())

// Bad - Modulators of a step on a previous line should be indented
g.V().
  group().
  by().
  by(bothE().count())

// Good
g.V().
  group().
    by().
    by(bothE().count())

// Bad - You have ignored the indent rules to achieve the temporary satisfaction of vertical alignment
g.V().local(union(identity(),
                  bothE().count()).
            fold())

// Good
g.V().
  local(
    union(
      identity(),
      bothE().count()).
    fold())

// Bad - When multiple anonymous traversals are passed as arguments to a function, each newline which is not the first of line of the step should be indented to make it more clear where the distinction between each argument goes.
g.V().
  has('person','name','marko').
  fold().
  coalesce(
    unfold(),
    addV('person').
    property('name','marko').
    property('age',29))

// Good - We make it clear that the coalesce step takes two traversals as arguments
g.V().
  has('person','name','marko').
  fold().
  coalesce(
    unfold(),
    addV('person').
      property('name','marko').
      property('age',29))`,
  },
  {
    title: 'Keep as()-steps at the end of each line',
    explanation: `The end of the line is a natural place to assign a label to a step. It's okay if the as()-step is in the middle of the line if there are multiple consecutive label assignments, or if the line is so short that a newline doesn't make sense. Maybe a better way to put it is to not start a line with an as()-step, unless you're using it inside a match()-step of course.`,
    example: `// Bad
g.V().
  as('a').
  out('created').
  as('b').
  select('a','b')

// Good
g.V().as('a').
  out('created').as('b').
  select('a','b')

// Good
g.V().as('a').out('created').as('b').select('a','b')`,
  },
  {
    title: 'Add linebreak after punctuation, not before',
    explanation: `While adding the linebreak before the punctuation looks good in most cases, it introduces alignment problems when not all lines start with a punctuation. You never know if the next line should be indented relative to the punctuation of the previous line or the method of the previous line. Switching between having the punctuation at the start or the end of the line depending on whether it works in a particular case requires much brainpower (which we don't have), so it's better to be consistent. Adding the punctuation before the linebreak also means that you can know if you have reached the end of the query without reading the next line.`,
    example: `// Bad - Looks okay, though
g.V().has('name','marko')
     .out('knows')
     .has('age', gt(29))
     .values('name')

// Good
g.V().
  has('name','marko').
  out('knows').
  has('age', gt(29)).
  values('name')

// Bad - Punctuation at the start of the line makes the transition from filter to select to count too smooth
g.V()
  .hasLabel("person")
  .group()
    .by(values("name", "age").fold())
  .unfold()
  .filter(
    select(values)
    .count(local)
    .is(gt(1)))

// Good - Keeping punctuation at the end of each line, more clearly shows the query structure
g.V().
  hasLabel("person").
  group().
    by(values("name", "age").fold()).
  unfold().
  filter(
    select(values).
    count(local).
    is(gt(1)))`,
  },
  {
    title:
      'Add linebreak and indentation for nested traversals which are long enough to span multiple lines',
    explanation: '',
    example: `// Bad - Not newlining the first argument of a function whose arguments span over multipe lines causes the arguments to not align.
g.V().
  hasLabel("person").
  groupCount().
    by(values("age").
      choose(is(lt(28)),
        constant("young"),
        choose(is(lt(30)),
          constant("old"),
          constant("very old"))))

// Bad - We talked about this in the indentation section, didn't we?
g.V().
  hasLabel("person").
  groupCount().
    by(values("age").
       choose(is(lt(28)),
              constant("young"),
              choose(is(lt(30)),
                     constant("old"),
                     constant("very old"))))

// Good
g.V().
  hasLabel("person").
  groupCount().
    by(
      values("age").
      choose(
        is(lt(28)),
        constant("young"),
        choose(
          is(lt(30)),
          constant("old"),
          constant("very old"))))`,
  },
  {
    title:
      'Place all trailing parentheses on a single line instead of distinct lines',
    explanation:
      'Aligning the end parenthesis with the step to which the start parenthesis belongs might make it easier to check that the number of parentheses is correct, but looks ugly and wastes a lot of space.',
    example: `// Bad
g.V().
  hasLabel("person").
  groupCount().
    by(
      values("age").
      choose(
        is(lt(28)),
        constant("young"),
        choose(
          is(lt(30)),
          constant("old"),
          constant("very old")
        )
      )
    )

// Good
g.V().
  hasLabel("person").
  groupCount().
    by(
      values("age").
      choose(
        is(lt(28)),
        constant("young"),
        choose(
          is(lt(30)),
          constant("old"),
          constant("very old"))))`,
  },
  {
    title:
      'Use // for single line comments. Place single line comments on a newline above the subject of the comment.',
    explanation: '',
    example: `// Bad
g.V().
  has('name','alice').out('bought'). // Find everything that Alice has bought
  in('bought').dedup().values('name') // Find everyone who have bought some of the same things as Alice

// Good
g.V().
  // Find everything that Alice has bought
  has('name','alice').out('bought').
  // Find everyone who have bought some of the same things as Alice
  in('bought').dedup().values('name')`,
  },
  {
    title: 'Use single quotes for strings',
    explanation:
      'Use single quotes for literal string values. If the string contains double quotes or single quotes, surround the string with the type of quote which creates the fewest escaped characters.',
    example: `// Bad - Use single quotes where possible
g.V().has("Movie", "name", "It's a wonderful life")

// Bad - Escaped single quotes are even worse than double quotes
g.V().has('Movie', 'name', 'It\'s a wonderful life')

// Good
g.V().has('Movie', 'name', "It's a wonderful life")`,
  },
  {
    title: 'Write idiomatic Gremlin code',
    explanation: `If there is a simpler way, do it the simpler way. Use the Gremlin methods for what they're worth.`,
    example: `// Bad
g.V().outE().inV()

// Good
g.V().out()


// Bad
g.V().
  has('name', 'alice').
  outE().hasLabel('bought').inV().
  values('name')

// Good
g.V().
  has('name','alice').
  out('bought').
  values('name')


// Bad
g.V().hasLabel('person').has('name', 'alice')

// Good
g.V().has('person', 'name', 'alice')`,
  },
];

module.exports = { rules };

  return module.exports;
})();

modules['src/components/queryInput/QueryInput.js'] = (() => {
  const module = { exports: {} };
  const { html } = include('src/libs/simpleHTML/SimpleHTML.js');
const { InputTextColor } = include(
  'src/libs/simpleColorPalette/SimpleColorPalette.js'
);

const getQueryInputStyle = () => `
  height: calc(100vh / 4);
  border-radius: 5px;
  font-family: "Courier New", Courier, monospace;
  background: rgba(0, 0, 0, 0.05);
  outline: none;
  font-size: 16px;
  padding: 10px;
  border: none;
  resize: none;
  width: 100%;
  box-shadow: inset rgba(0, 0, 0, 0.5) 0 0 10px -5px;
  color: ${InputTextColor};
  box-sizing: border-box;
`;

const QueryInput = (getProps) => {
  const getOnInput = () => getProps().oninput;
  const getValue = () => getProps().value;
  return html('div', { style: 'padding: 10px;' }, [
    html(
      'textarea',
      () => ({
        oninput: getOnInput(),
        style: getQueryInputStyle(),
        value: getValue(),
        rows: 20,
      }),
      []
    ),
  ]);
};

module.exports = QueryInput;

  return module.exports;
})();

modules['src/components/code/Code.js'] = (() => {
  const module = { exports: {} };
  const { html, If } = include('src/libs/simpleHTML/SimpleHTML.js');
const { DisabledTextColor, TextColor } = include(
  'src/libs/simpleColorPalette/SimpleColorPalette.js'
);

const getCodeStyle = () => `
  border-radius: 5px;
  font-family: "Courier New", Courier, monospace;
  background: rgba(0, 0, 0, 0.05);
  outline: none;
  font-size: 15px;
  padding: 10px;
  border: none;
  resize: none;
  box-shadow: inset rgba(0, 0, 0, 0.5) 0 0 10px -5px;
  white-space: pre-wrap;
  overflow: auto;
`;

const Code = (getProps) => {
  const getInnerText = () => getProps().innerText;
  const getMaxLineLength = () => getProps().maxLineLength;
  const element = html('div', { style: 'padding: 10px;' }, [
    html('div', { style: getCodeStyle() + 'position: relative;' }, [
      html(
        'span',
        () => ({
          style: `color: ${TextColor}; line-height: 20px; font-size: 15px;`,
          innerText: getInnerText(),
        }),
        []
      ),
      If(
        () => getMaxLineLength() !== undefined,
        () => [
          html(
            'div',
            () => ({
              style: `top: 0;
                      left: 0;
                      width: calc(10px + ${getMaxLineLength()}ch);
                      border-right: 1px solid ${DisabledTextColor};
                      position: absolute;
                      height: 100%;
                      pointer-events: none;`,
            }),
            []
          ),
        ]
      ),
    ]),
  ]);
  return element;
};

module.exports = Code;

  return module.exports;
})();

modules['src/libs/simpleFP/SimpleFP.js'] = (() => {
  const module = { exports: {} };
  const last = (array) => array.slice(-1)[0];

const pipe = (...fns) => (value) => fns.reduce((value, fn) => fn(value), value);

module.exports = { last, pipe };

  return module.exports;
})();

modules['src/libs/gremlint/parseToSyntaxTree/ParseToSyntaxTree.js'] = (() => {
  const module = { exports: {} };
  const { last, pipe } = include('src/libs/simpleFP/SimpleFP.js');

const tokenizeOnTopLevelPunctuation = (query) => {
  word = '';
  parenthesesCount = 0;
  squareBracketCount = 0;
  curlyBracketCount = 0;
  isInsideSingleQuoteString = false;
  query.split('').forEach((char) => {
    if (char === '(' && !isInsideSingleQuoteString) {
      parenthesesCount++;
      word += '(';
      return;
    }
    if (char === '[' && !isInsideSingleQuoteString) {
      squareBracketCount++;
      word += '[';
      return;
    }
    if (char === '{' && !isInsideSingleQuoteString) {
      curlyBracketCount++;
      word += '{';
      return;
    }
    if (char === ')' && !isInsideSingleQuoteString) {
      parenthesesCount--;
      word += ')';
      return;
    }
    if (char === ']' && !isInsideSingleQuoteString) {
      squareBracketCount--;
      word += ']';
      return;
    }
    if (char === '}' && !isInsideSingleQuoteString) {
      curlyBracketCount--;
      word += '}';
      return;
    }
    if (char === "'") {
      isInsideString = !isInsideSingleQuoteString;
      word += "'";
      return;
    }
    if (char === '.') {
      word +=
        isInsideSingleQuoteString ||
        parenthesesCount ||
        squareBracketCount ||
        curlyBracketCount
          ? '.'
          : String.fromCharCode(28);
      return;
    }
    word += char;
  });
  return word
    .split(String.fromCharCode(28))
    .filter((token) => token !== '')
    .map((token) => token.trim());
};

const tokenizeOnTopLevelComma = (query) => {
  word = '';
  parenthesesCount = 0;
  squareBracketCount = 0;
  curlyBracketCount = 0;
  isInsideSingleQuoteString = false;
  query.split('').forEach((char) => {
    if (char === '(' && !isInsideSingleQuoteString) {
      parenthesesCount++;
      word += '(';
      return;
    }
    if (char === '[' && !isInsideSingleQuoteString) {
      squareBracketCount++;
      word += '[';
      return;
    }
    if (char === '{' && !isInsideSingleQuoteString) {
      curlyBracketCount++;
      word += '{';
      return;
    }
    if (char === ')' && !isInsideSingleQuoteString) {
      parenthesesCount--;
      word += ')';
      return;
    }
    if (char === ']' && !isInsideSingleQuoteString) {
      squareBracketCount--;
      word += ']';
      return;
    }
    if (char === '}' && !isInsideSingleQuoteString) {
      curlyBracketCount--;
      word += '}';
      return;
    }
    if (char === "'") {
      isInsideString = !isInsideSingleQuoteString;
      word += "'";
      return;
    }
    if (char === ',') {
      word +=
        isInsideSingleQuoteString ||
        parenthesesCount ||
        squareBracketCount ||
        curlyBracketCount
          ? ','
          : String.fromCharCode(28);
      return;
    }
    word += char;
  });
  return word
    .split(String.fromCharCode(28))
    .filter((token) => token !== '')
    .map((token) => token.trim());
};

const tokenizeOnTopLevelParentheses = (query) => {
  word = '';
  parenthesesCount = 0;
  squareBracketCount = 0;
  curlyBracketCount = 0;
  isInsideSingleQuoteString = false;
  query.split('').forEach((char) => {
    if (char === '(' && !isInsideSingleQuoteString) {
      if (parenthesesCount === 0) {
        word += String.fromCharCode(28);
      }
      parenthesesCount++;
      word += '(';
      return;
    }
    if (char === '[' && !isInsideSingleQuoteString) {
      squareBracketCount++;
      word += '[';
      return;
    }
    if (char === '{' && !isInsideSingleQuoteString) {
      curlyBracketCount++;
      word += '{';
      return;
    }
    if (char === ')' && !isInsideSingleQuoteString) {
      parenthesesCount--;
      word += ')';
      return;
    }
    if (char === ']' && !isInsideSingleQuoteString) {
      squareBracketCount--;
      word += ']';
      return;
    }
    if (char === '}' && !isInsideSingleQuoteString) {
      curlyBracketCount--;
      word += '}';
      return;
    }
    if (char === "'") {
      isInsideString = !isInsideSingleQuoteString;
      word += "'";
      return;
    }
    word += char;
  });
  return word
    .split(String.fromCharCode(28))
    .filter((token) => token !== '')
    .map((token) => token.trim());
};

const isWrappedInParentheses = (token) => {
  if (token.length < 2) return false;
  if (token.charAt(0) !== '(') return false;
  if (token.slice(-1) !== ')') return false;
  return true;
};

const isString = (token) => {
  if (token.length < 2) return false;
  if (token.charAt(0) !== token.substr(-1)) return false;
  if (['"', "'"].includes(token.charAt(0))) return true;
  return false;
};

const isMethodInvocation = (token) => {
  return pipe(
    tokenizeOnTopLevelParentheses,
    last,
    isWrappedInParentheses
  )(token);
};

const trimParentheses = (expression) => expression.slice(1, -1);

const getMethodTokenAndArgumentTokensFromMethodInvocation = (token) => {
  // The word before the first parenthesis is the method name
  // The token may be a double application of a curried function, so we cannot
  // assume that the first opening parenthesis is closed by the last closing
  // parenthesis
  const tokens = tokenizeOnTopLevelParentheses(token);
  return {
    methodToken: tokens.slice(0, -1).join(''),
    argumentTokens: pipe(
      trimParentheses,
      tokenizeOnTopLevelComma
    )(tokens.slice(-1)[0]),
  };
};

const tokenize = pipe(tokenizeOnTopLevelPunctuation);

const parseToSyntaxTree = (query) => {
  const tokens = tokenizeOnTopLevelPunctuation(query);
  if (tokens.length === 1) {
    const token = tokens[0];
    if (isMethodInvocation(token)) {
      const {
        methodToken,
        argumentTokens,
      } = getMethodTokenAndArgumentTokensFromMethodInvocation(token);
      return {
        type: 'method',
        method: parseToSyntaxTree(methodToken),
        arguments: argumentTokens.map(parseToSyntaxTree),
      };
    }
    if (isString(token)) {
      return {
        type: 'string',
        string: token,
      };
    }
    return {
      type: 'word',
      word: token,
    };
  }
  return {
    type: 'traversal',
    steps: tokens.map(parseToSyntaxTree),
  };
};

module.exports = {
  parseToSyntaxTree,
};

  return module.exports;
})();

modules['src/libs/simpleStyle/SimpleStyle.js'] = (() => {
  const module = { exports: {} };
  const {
  TextColor,
  InputTextColor,
  HighlightedTextColor,
  DisabledTextColor,
  HighlightColor,
  White,
} = include('src/libs/simpleColorPalette/SimpleColorPalette.js');

// A unit is 20px
// vertical-align: bottom prevents half a pixel from getting added to the height
const getInlineContainerStyle = (widthUnits, heightUnits) => `
  display: inline-block;
  vertical-align: bottom;
  padding: 10px;
  box-sizing: border-box;
  height: ${heightUnits * 20}px;
  width: ${widthUnits * 20}px;
`;

const getInputStyle = () => `
  border-radius: 5px;
  background: rgba(0, 0, 0, 0.05);
  outline: none;
  font-size: 16px;
  padding: 10px;
  border: none;
  box-shadow: inset rgba(0, 0, 0, 0.5) 0 0 10px -5px;
  color: ${InputTextColor};
`;

// Used for links
// inline-block is needed for the element to be able to have a height
const getLinkStyle = (isHovered, isSelected) => `
  text-decoration: none;
  display: inline-block;
  height: 20px;
  line-height: 20px;
  font-size: 15px;
  color: ${isHovered || isSelected ? HighlightedTextColor : TextColor};
  border-bottom: ${isSelected ? `2px solid ${HighlightColor}` : 'none'};
`;

// Used for buttons to make them look like text
const getTextButtonStyle = (isHovered) => `
  height: 20px;
  line-height: 20px;
  font-size: 15px;
  color: ${isHovered ? HighlightedTextColor : TextColor};
  background: none;
  border: none;
  cursor: pointer;
  padding: 0;
  outline: none;
`;

// Used for spans and divs and what not
const getTextStyle = () => `
  height: 20px;
  line-height: 20px;
  font-size: 15px;
  color: ${TextColor};
`;

module.exports = {
  getInlineContainerStyle,
  getInputStyle,
  getLinkStyle,
  getTextButtonStyle,
  getTextStyle,
};

  return module.exports;
})();

modules['src/components/navigationButton/NavigationButton.js'] = (() => {
  const module = { exports: {} };
  const { html } = include('src/libs/simpleHTML/SimpleHTML.js');
const { getInlineContainerStyle, getLinkStyle } = include(
  'src/libs/simpleStyle/SimpleStyle.js'
);

const NavigationButton = (getProps) => {
  const getIsSelected = () => getProps().isSelected;
  const getHref = () => getProps().href;
  const getLabel = () => getProps().label;

  let isHovered = false;
  const getIsHovered = () => isHovered;
  const setIsHovered = (value) => {
    isHovered = value;
    element.update();
  };

  const element = html(
    'span',
    () => ({ style: getInlineContainerStyle(8, 2) }),
    [
      html(
        'a',
        () => ({
          href: getHref(),
          innerText: getLabel(),
          style: getLinkStyle(getIsHovered(), getIsSelected()),
          onmouseenter: () => setIsHovered(true),
          onmouseleave: () => setIsHovered(false),
        }),
        []
      ),
    ]
  );

  return element;
};

module.exports = NavigationButton;

  return module.exports;
})();

modules['src/components/navigator/Navigator.js'] = (() => {
  const module = { exports: {} };
  const { html } = include('src/libs/simpleHTML/SimpleHTML.js');
const { White } = include('src/libs/simpleColorPalette/SimpleColorPalette.js');
const NavigationButton = include(
  'src/components/navigationButton/NavigationButton.js'
);

const getQueryFormatterButtonProps = (getCurrentRoute) => () => ({
  isSelected: getCurrentRoute() === '/',
  label: 'Query formatter',
  href: '#!/',
});

const getStyleGuideButtonProps = (getCurrentRoute) => () => ({
  isSelected: getCurrentRoute() === '/style-guide',
  label: 'Style guide',
  href: '#!/style-guide',
});

const Navigator = (getProps) => {
  const getCurrentRoute = () => getProps().currentRoute;
  const element = html('div', {}, [
    html(
      'div',
      {
        style: `background: ${White};
                box-shadow: ${White} 0 0 10px;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                z-index: 1;`,
      },
      [
        html(
          'div',
          {
            style:
              'width: min(800px, 100vw); margin-left: calc(50vw - min(400px, 50vw));',
          },
          [
            NavigationButton(getQueryFormatterButtonProps(getCurrentRoute)),
            NavigationButton(getStyleGuideButtonProps(getCurrentRoute)),
          ]
        ),
      ]
    ),
    html('div', { style: 'height:40px;' }, []),
  ]);
  return element;
};

module.exports = Navigator;

  return module.exports;
})();

modules['src/components/textButton/TextButton.js'] = (() => {
  const module = { exports: {} };
  const { html } = include('src/libs/simpleHTML/SimpleHTML.js');
const { getTextButtonStyle } = include('src/libs/simpleStyle/SimpleStyle.js');

const TextButton = (getProps) => {
  const getHref = () => getProps().href;
  const getLabel = () => getProps().label;
  const getOnClick = () => getProps().onclick;

  let isHovered = false;
  const getIsHovered = () => isHovered;
  const setIsHovered = (value) => {
    isHovered = value;
    element.update();
  };

  const getSpanStyle = () => `
    display: inline-block;
    padding: 10px;
    box-sizing: border-box;
  `;

  const element = html('span', () => ({ style: getSpanStyle() }), [
    html(
      'button',
      () => ({
        href: getHref(),
        innerText: getLabel(),
        style: getTextButtonStyle(getIsHovered()),
        onmouseenter: () => setIsHovered(true),
        onmouseleave: () => setIsHovered(false),
        onclick: getOnClick(),
      }),
      []
    ),
  ]);

  return element;
};

module.exports = TextButton;

  return module.exports;
})();

modules['src/components/title/Title.js'] = (() => {
  const module = { exports: {} };
  const { html } = include('src/libs/simpleHTML/SimpleHTML.js');
const { TextColor } = include(
  'src/libs/simpleColorPalette/SimpleColorPalette.js'
);

const Title = (getProps) => {
  const getInnerText = () => getProps().innerText;
  const element = html(
    'div',
    { style: getInnerText() ? 'padding: 10px;' : '' },
    [
      html(
        'span',
        {
          style: `color: ${TextColor}; line-height: 30px; font-size: 25px;`,
          innerText: getInnerText(),
        },
        []
      ),
    ]
  );
  return element;
};

module.exports = Title;

  return module.exports;
})();

modules['src/components/paragraph/Paragraph.js'] = (() => {
  const module = { exports: {} };
  const { html } = include('src/libs/simpleHTML/SimpleHTML.js');
const { TextColor } = include(
  'src/libs/simpleColorPalette/SimpleColorPalette.js'
);

const Paragraph = (getProps) => {
  const getInnerText = () => getProps().innerText;
  const element = html(
    'div',
    () => ({ style: getInnerText() ? 'padding: 10px;' : '' }),
    [
      html(
        'span',
        {
          style: `color: ${TextColor}; line-height: 20px; font-size: 15px;`,
          innerText: getInnerText(),
        },
        []
      ),
    ]
  );
  return element;
};

module.exports = Paragraph;

  return module.exports;
})();

modules['src/components/spacer/Spacer.js'] = (() => {
  const module = { exports: {} };
  const { html } = include('src/libs/simpleHTML/SimpleHTML.js');

const Spacer = () => html('div', { style: 'height: 20px' }, []);

module.exports = Spacer;

  return module.exports;
})();

modules['src/components/styleGuideRule/StyleGuideRule.js'] = (() => {
  const module = { exports: {} };
  const Title = include('src/components/title/Title.js');
const Paragraph = include('src/components/paragraph/Paragraph.js');
const Code = include('src/components/code/Code.js');
const Spacer = include('src/components/spacer/Spacer.js');
const { html } = include('src/libs/simpleHTML/SimpleHTML.js');

const StyleGuideRule = (getProps) => {
  const getTitle = () => getProps().title;
  const getExplanation = () => getProps().explanation;
  const getExample = () => getProps().example;

  return html('div', {}, [
    Title(() => ({ innerText: getTitle() })),
    Paragraph(() => ({ innerText: getExplanation() })),
    Code(() => ({ innerText: getExample() })),
    Spacer(() => ({})),
  ]);
};

module.exports = StyleGuideRule;

  return module.exports;
})();

modules['src/views/styleGuide/StyleGuide.js'] = (() => {
  const module = { exports: {} };
  const StyleGuideRule = include(
  'src/components/styleGuideRule/StyleGuideRule.js'
);
const { html, Each } = include('src/libs/simpleHTML/SimpleHTML.js');
const { rules } = include('src/views/styleGuide/rules/Rules.js');

const StyleGuide = () =>
  html('div', {}, [
    Each(
      () => rules,
      (getCurrentValue) => [
        StyleGuideRule(() => ({
          title: getCurrentValue().title,
          explanation: getCurrentValue().explanation,
          example: getCurrentValue().example,
        })),
      ]
    ),
  ]);

module.exports = StyleGuide;

  return module.exports;
})();

modules['src/libs/gremlint/formatSyntaxTree/formatString/FormatString.js'] = (() => {
  const module = { exports: {} };
  const formatString = (config) => (syntaxTree) => {
  return {
    type: 'string',
    string: syntaxTree.string,
    indentation: config.indentation,
  };
};

module.exports = { formatString };

  return module.exports;
})();

modules['src/libs/gremlint/formatSyntaxTree/formatWord/FormatWord.js'] = (() => {
  const module = { exports: {} };
  const formatWord = (config) => (syntaxTree) => {
  return {
    type: 'word',
    word: syntaxTree.word,
    indentation: config.indentation,
    shouldStartWithDot: config.shouldStartWithDot,
    shouldEndWithDot: config.shouldEndWithDot,
  };
};

module.exports = { formatWord };

  return module.exports;
})();

modules['src/libs/gremlint/utils.js'] = (() => {
  const module = { exports: {} };
  const spaces = (numberOfSpaces) => Array(numberOfSpaces + 1).join(' ');

module.exports = {
  spaces,
};

  return module.exports;
})();

modules['src/libs/gremlint/recreateQueryStringFromFormattedSyntaxTree/RecreateQueryStringFromFormattedSyntaxTree.js'] = (() => {
  const module = { exports: {} };
  const { spaces } = include('src/libs/gremlint/utils.js');

const recreateQueryStringFromFormattedSyntaxTree = (syntaxTree) => {
  if (syntaxTree.type === 'traversal') {
    return syntaxTree.stepGroups
      .map((stepGroup) =>
        stepGroup.steps
          .map(recreateQueryStringFromFormattedSyntaxTree)
          .join('.')
      )
      .join('\n');
  }
  if (syntaxTree.type === 'method') {
    return (
      (syntaxTree.shouldStartWithDot ? '.' : '') +
      [
        recreateQueryStringFromFormattedSyntaxTree(syntaxTree.method) + '(',
        syntaxTree.argumentGroups
          .map((arguments) =>
            arguments.map(recreateQueryStringFromFormattedSyntaxTree).join(', ')
          )
          .join(',\n') +
          ')' +
          (syntaxTree.shouldEndWithDot ? '.' : ''),
      ].join(syntaxTree.argumentsShouldStartOnNewLine ? '\n' : '')
    );
  }
  if (syntaxTree.type === 'string') {
    return spaces(syntaxTree.indentation) + syntaxTree.string;
  }
  if (syntaxTree.type === 'word') {
    return (
      spaces(syntaxTree.indentation) +
      (syntaxTree.shouldStartWithDot ? '.' : '') +
      syntaxTree.word +
      (syntaxTree.shouldEndWithDot ? '.' : '')
    );
  }
};

module.exports = {
  recreateQueryStringFromFormattedSyntaxTree,
};

  return module.exports;
})();

modules['src/libs/gremlint/recreateQueryOnelinerFromSyntaxTree/RecreateQueryOnelinerFromSyntaxTree.js'] = (() => {
  const module = { exports: {} };
  const { spaces } = include('src/libs/gremlint/utils.js');

const recreateQueryOnelinerFromSyntaxTree = (indentation = 0) => (
  syntaxTree
) => {
  switch (syntaxTree.type) {
    case 'traversal':
      return (
        spaces(indentation) +
        syntaxTree.steps.map(recreateQueryOnelinerFromSyntaxTree()).join('.')
      );
    case 'method':
      return (
        spaces(indentation) +
        recreateQueryOnelinerFromSyntaxTree()(syntaxTree.method) +
        '(' +
        syntaxTree.arguments
          .map(recreateQueryOnelinerFromSyntaxTree())
          .join(', ') +
        ')'
      );
    case 'string':
      return spaces(indentation) + syntaxTree.string;
    case 'word':
      return spaces(indentation) + syntaxTree.word;
  }
};

module.exports = {
  recreateQueryOnelinerFromSyntaxTree,
};

  return module.exports;
})();

modules['src/libs/gremlint/formatSyntaxTree/utils.js'] = (() => {
  const module = { exports: {} };
  const withIndentation = (indentation) => (config) => ({
  ...config,
  indentation,
});

const withZeroIndentation = (config) => withIndentation(0)(config);

const withIncreasedIndentation = (indentationIncrease) => (config) => ({
  ...config,
  indentation: config.indentation + indentationIncrease,
});

const withDotInfo = ({ shouldStartWithDot, shouldEndWithDot }) => (config) => {
  return { ...config, shouldStartWithDot, shouldEndWithDot };
};

const withZeroDotInfo = (config) => ({
  ...config,
  shouldStartWithDot: false,
  shouldEndWithDot: false,
});

const withNoEndDotInfo = (config) => ({
  ...config,
  shouldEndWithDot: false,
});

module.exports = {
  withIndentation,
  withZeroIndentation,
  withIncreasedIndentation,
  withDotInfo,
  withZeroDotInfo,
  withNoEndDotInfo,
};

  return module.exports;
})();

modules['src/libs/gremlint/formatSyntaxTree/formatMethod/FormatMethod.js'] = (() => {
  const module = { exports: {} };
  const { pipe } = include('src/libs/simpleFP/SimpleFP.js');
const { recreateQueryOnelinerFromSyntaxTree } = include(
  'src/libs/gremlint/recreateQueryOnelinerFromSyntaxTree/RecreateQueryOnelinerFromSyntaxTree.js'
);
const {
  withIncreasedIndentation,
  withZeroIndentation,
  withZeroDotInfo,
  withNoEndDotInfo,
} = include('src/libs/gremlint/formatSyntaxTree/utils.js');

// Groups arguments into argument groups an adds an indentation property
const formatMethod = (formatSyntaxTree) => (config) => (syntaxTree) => {
  const recreatedQuery = recreateQueryOnelinerFromSyntaxTree(
    config.indentation
  )(syntaxTree);
  if (recreatedQuery.length <= config.maxLineLength) {
    return {
      type: 'method',
      method: formatSyntaxTree(withNoEndDotInfo(config))(syntaxTree.method),
      argumentGroups: [
        syntaxTree.arguments.map(
          formatSyntaxTree(pipe(withZeroIndentation, withZeroDotInfo)(config))
        ),
      ],
      argumentsShouldStartOnNewLine: false,
      indentation: config.indentation,
      shouldEndWithDot: config.shouldEndWithDot,
    };
  }
  // shouldEndWithDot has to reside on the method object, so the end dot can be
  // placed after the method parentheses. shouldStartWithDot has to be passed on
  // further down so the start dot can be placed after the indentation.
  return {
    type: 'method',
    method: formatSyntaxTree(withNoEndDotInfo(config))(syntaxTree.method),
    argumentGroups: syntaxTree.arguments.map((step) => [
      formatSyntaxTree(
        pipe(withIncreasedIndentation(2), withZeroDotInfo)(config)
      )(step),
    ]),
    argumentsShouldStartOnNewLine: true,
    shouldEndWithDot: config.shouldEndWithDot,
  };
};

module.exports = { formatMethod };

  return module.exports;
})();

modules['src/libs/gremlint/formatSyntaxTree/formatTraversal/getStepGroups/utils.js'] = (() => {
  const module = { exports: {} };
  const isTraversalSource = (step) => step.type === 'word' && step.word === 'g';

const isModulator = (step) =>
  step.type === 'method' &&
  step.method.type === 'word' &&
  ['by', 'as', 'option', 'from', 'to', 'read', 'write'].includes(
    step.method.word
  );

module.exports = { isTraversalSource, isModulator };

  return module.exports;
})();

modules['src/libs/gremlint/formatSyntaxTree/formatTraversal/getStepGroups/GetStepGroups.js'] = (() => {
  const module = { exports: {} };
  const { pipe } = include('src/libs/simpleFP/SimpleFP.js');
const { withZeroIndentation, withIncreasedIndentation, withDotInfo } = include(
  'src/libs/gremlint/formatSyntaxTree/utils.js'
);
const { isTraversalSource, isModulator } = include(
  'src/libs/gremlint/formatSyntaxTree/formatTraversal/getStepGroups/utils.js'
);

const getStepGroups = (formatSyntaxTree, steps, config) => {
  const { stepGroups } = steps.reduce(
    ({ stepsInStepGroup, stepGroups }, step, index, steps) => {
      const isFirstStepInStepGroup = !stepsInStepGroup.length;

      // If it should be the last step in a line
      // We don't want to newline after words which are not methods. For
      // instance, g.V() should be one one line, as should __.as
      if (step.type === 'method' || index === steps.length - 1) {
        const isFirstStepGroup = stepGroups.length === 0;
        const isLastStepGroup = index === steps.length - 1;

        // If it is the first (and last) step in a line, format it with
        // indentation, otherwise, remove the indentation
        if (isFirstStepInStepGroup) {
          const traversalSourceIndentationIncrease =
            stepGroups[0] && isTraversalSource(stepGroups[0].steps[0]) ? 2 : 0;
          const modulatorIndentationIncrease = isModulator(step) ? 2 : 0;
          const indentationIncrease =
            traversalSourceIndentationIncrease + modulatorIndentationIncrease;

          // This is the only step in the step group, so it is the first step in
          // the step group. It should only start with a dot if it is not the
          // first stepGroup and config.shouldPlaceDotsAfterNewlines
          const shouldStartWithDot =
            !isFirstStepGroup && config.shouldPlaceDotsAfterNewlines;

          // It is the last step in a group and should only end with dot if not
          // config.shouldPlaceDotsAfterNewlines this is not the last step in
          // steps
          const shouldEndWithDot =
            !isLastStepGroup && !config.shouldPlaceDotsAfterNewlines;

          return {
            stepsInStepGroup: [],
            stepGroups: [
              ...stepGroups,
              {
                steps: [
                  formatSyntaxTree(
                    pipe(
                      withIncreasedIndentation(indentationIncrease),
                      withDotInfo({ shouldStartWithDot, shouldEndWithDot })
                    )(config)
                  )(step),
                ],
              },
            ],
          };
        }
        // If it is the last (and also not first) step in a group
        return (() => {
          // This is not the first step in the step group, so it should not
          // start with a dot
          const shouldStartWithDot = false;

          // It is the last step in a group and should only end with dot if not
          // config.shouldPlaceDotsAfterNewlines this is not the last step in
          // steps
          const shouldEndWithDot =
            !isLastStepGroup && !config.shouldPlaceDotsAfterNewlines;

          return {
            stepsInStepGroup: [],
            stepGroups: [
              ...stepGroups,
              {
                steps: [
                  ...stepsInStepGroup,
                  formatSyntaxTree(
                    pipe(
                      withZeroIndentation,
                      withDotInfo({ shouldStartWithDot, shouldEndWithDot })
                    )(config)
                  )(step),
                ],
              },
            ],
          };
        })();
      }

      // If it is the first step in a group and also not the last one, format it
      // with indentation, otherwise, remove the indentation
      if (isFirstStepInStepGroup) {
        const isFirstStepGroup = stepGroups.length === 0;

        // It is the first step in a group and should start with a dot if it is
        // not the first stepGroup and config.shouldPlaceDotsAfterNewlines
        const shouldStartWithDot =
          !isFirstStepGroup && config.shouldPlaceDotsAfterNewlines;

        // It is the first step in a group, but not the last, so it should not
        // end with a dot.
        const shouldEndWithDot = false;

        return {
          stepsInStepGroup: [
            formatSyntaxTree(
              withDotInfo({ shouldStartWithDot, shouldEndWithDot })(config)
            )(step),
          ],
          stepGroups,
        };
      }
      return (() => {
        // If it is not the first step in a group and not the last one either
        const shouldStartWithDot = false;
        const shouldEndWithDot = false;
        return {
          stepsInStepGroup: [
            ...stepsInStepGroup,
            formatSyntaxTree(
              pipe(
                withZeroIndentation,
                withDotInfo({ shouldStartWithDot, shouldEndWithDot })
              )(config)
            )(step),
          ],
          stepGroups,
        };
      })();
    },
    { stepsInStepGroup: [], stepGroups: [] }
  );
  return stepGroups;
};

module.exports = { getStepGroups };

  return module.exports;
})();

modules['src/libs/gremlint/formatSyntaxTree/formatTraversal/FormatTraversal.js'] = (() => {
  const module = { exports: {} };
  const { pipe } = include('src/libs/simpleFP/SimpleFP.js');
const { recreateQueryOnelinerFromSyntaxTree } = include(
  'src/libs/gremlint/recreateQueryOnelinerFromSyntaxTree/RecreateQueryOnelinerFromSyntaxTree.js'
);
const { getStepGroups } = include(
  'src/libs/gremlint/formatSyntaxTree/formatTraversal/getStepGroups/GetStepGroups.js'
);
const { withDotInfo, withZeroIndentation } = include(
  'src/libs/gremlint/formatSyntaxTree/utils.js'
);

// Groups steps into step groups and adds an indentation property
const formatTraversal = (formatSyntaxTree) => (config) => (syntaxTree) => {
  const recreatedQuery = recreateQueryOnelinerFromSyntaxTree(
    config.indentation
  )(syntaxTree);
  if (recreatedQuery.length <= config.maxLineLength) {
    return {
      type: 'traversal',
      stepGroups: [
        {
          steps: syntaxTree.steps.map((step, stepIndex) =>
            formatSyntaxTree(
              stepIndex === 0 ? config : withZeroIndentation(config)
            )(step)
          ),
        },
      ],
    };
  }
  return {
    type: 'traversal',
    stepGroups: getStepGroups(formatSyntaxTree, syntaxTree.steps, config),
  };
};

module.exports = { formatTraversal };

  return module.exports;
})();

modules['src/libs/gremlint/formatSyntaxTree/FormatSyntaxTree.js'] = (() => {
  const module = { exports: {} };
  const { formatTraversal } = include(
  'src/libs/gremlint/formatSyntaxTree/formatTraversal/FormatTraversal.js'
);
const { formatMethod } = include(
  'src/libs/gremlint/formatSyntaxTree/formatMethod/FormatMethod.js'
);
const { formatString } = include(
  'src/libs/gremlint/formatSyntaxTree/formatString/FormatString.js'
);
const { formatWord } = include(
  'src/libs/gremlint/formatSyntaxTree/formatWord/FormatWord.js'
);

const formatSyntaxTree = (config) => (syntaxTree) => {
  switch (syntaxTree.type) {
    case 'traversal':
      return formatTraversal(formatSyntaxTree)(config)(syntaxTree);
    case 'method':
      return formatMethod(formatSyntaxTree)(config)(syntaxTree);
    case 'string':
      return formatString(config)(syntaxTree);
    case 'word':
      return formatWord(config)(syntaxTree);
  }
};

module.exports = { formatSyntaxTree };

  return module.exports;
})();

modules['src/libs/gremlint/Gremlint.js'] = (() => {
  const module = { exports: {} };
  const { pipe } = include('src/libs/simpleFP/SimpleFP.js');
const { parseToSyntaxTree } = include(
  'src/libs/gremlint/parseToSyntaxTree/ParseToSyntaxTree.js'
);
const { formatSyntaxTree } = include(
  'src/libs/gremlint/formatSyntaxTree/FormatSyntaxTree.js'
);
const { recreateQueryStringFromFormattedSyntaxTree } = include(
  'src/libs/gremlint/recreateQueryStringFromFormattedSyntaxTree/RecreateQueryStringFromFormattedSyntaxTree.js'
);

const formatQuery = (
  query,
  config = {
    indentation: 0,
    maxLineLength: 80,
    shouldPlaceDotsAfterNewlines: false,
  }
) => {
  return pipe(
    parseToSyntaxTree,
    formatSyntaxTree(config),
    recreateQueryStringFromFormattedSyntaxTree
  )(query);
};

module.exports = {
  formatQuery,
};

  return module.exports;
})();

modules['src/store/Store.js'] = (() => {
  const module = { exports: {} };
  const Observable = include('src/libs/observable/Observable.js');
const { formatQuery } = include('src/libs/gremlint/Gremlint.js');

const atom = (initialValue) => {
  const observable$ = new Observable(initialValue);
  const get = () => observable$.value;
  const set = (value) => {
    observable$.value = value;
  };
  const addChangeListener = (callback) =>
    addEventListener(observable$.id, callback);
  return [get, set, addChangeListener];
};

const [getQueryInput, setQueryInput, addQueryInputChangeListener] = atom('');

const [getQueryOutput, setQueryOutput, addQueryOutputChangeListener] = atom('');

const [
  getShowAdvancedOptions,
  setShowAdvancedOptions,
  addShowAdvancedOptionsChangeListener,
] = atom(false);

const [getIndentation, _setIndentation, addIndentationChangeListener] = atom(0);
const setIndentation = (value) => {
  const indentation = parseInt(value);
  if (isNaN(indentation)) return;
  if (indentation < 0) {
    _setIndentation(0);
    return;
  }
  const maxLineLength = getMaxLineLength();
  if (indentation > maxLineLength) {
    _setIndentation(maxLineLength);
    return;
  }
  _setIndentation(indentation);
};

const [
  getMaxLineLength,
  _setMaxLineLength,
  addMaxLineLengthChangeListener,
] = atom(72);
const setMaxLineLength = (value) => {
  const maxLineLength = parseInt(value);
  if (isNaN(maxLineLength)) return;
  if (maxLineLength < 0) {
    _setMaxLineLength(0);
    return;
  }
  _setMaxLineLength(maxLineLength);
};

addQueryInputChangeListener(({ detail }) => {
  setQueryOutput(
    formatQuery(detail, {
      indentation: getIndentation(),
      maxLineLength: getMaxLineLength(),
    })
  );
});

addIndentationChangeListener(() => {
  setQueryOutput(
    formatQuery(getQueryInput(), {
      indentation: getIndentation(),
      maxLineLength: getMaxLineLength(),
    })
  );
});

addMaxLineLengthChangeListener(() => {
  setQueryOutput(
    formatQuery(getQueryInput(), {
      indentation: getIndentation(),
      maxLineLength: getMaxLineLength(),
    })
  );
});

module.exports = {
  getQueryInput,
  setQueryInput,
  addQueryInputChangeListener,

  getQueryOutput,
  setQueryOutput,
  addQueryOutputChangeListener,

  getShowAdvancedOptions,
  setShowAdvancedOptions,
  addShowAdvancedOptionsChangeListener,

  getIndentation,
  setIndentation,
  addIndentationChangeListener,

  getMaxLineLength,
  setMaxLineLength,
  addMaxLineLengthChangeListener,
};

  return module.exports;
})();

modules['src/views/queryFormatter/advancedOptions/AdvancedOptions.js'] = (() => {
  const module = { exports: {} };
  const { html } = include('src/libs/simpleHTML/SimpleHTML.js');
const {
  getIndentation,
  setIndentation,
  getMaxLineLength,
  setMaxLineLength,
} = include('src/store/Store.js');
const { getInlineContainerStyle, getInputStyle, getTextStyle } = include(
  'src/libs/simpleStyle/SimpleStyle.js'
);

const AdvancedOptions = () => {
  const element = html('div', {}, [
    html('div', { style: 'padding: 10px;' }, [
      html(
        'span',
        {
          innerText: 'Indentation:',
          style: getTextStyle() + getInlineContainerStyle(8, 2),
        },
        []
      ),
      html(
        'input',
        () => ({
          style: getInputStyle() + getInlineContainerStyle(8, 2),
          type: 'number',
          min: 0,
          max: getMaxLineLength(),
          value: getIndentation(),
          oninput: ({ target }) => setIndentation(target.value),
        }),
        []
      ),
    ]),
    html('div', { style: 'padding: 10px;' }, [
      html(
        'span',
        {
          innerText: 'Max line length:',
          style: getTextStyle() + getInlineContainerStyle(8, 2),
        },
        []
      ),
      html(
        'input',
        {
          style: getInputStyle() + getInlineContainerStyle(8, 2),
          type: 'number',
          min: 0,
          value: getMaxLineLength(),
          oninput: ({ target }) => setMaxLineLength(target.value),
        },
        []
      ),
    ]),
  ]);
  return element;
};

module.exports = AdvancedOptions;

  return module.exports;
})();

modules['src/views/queryFormatter/QueryFormatter.js'] = (() => {
  const module = { exports: {} };
  const QueryInput = include('src/components/queryInput/QueryInput.js');
const Code = include('src/components/code/Code.js');
const TextButton = include('src/components/textButton/TextButton.js');
const AdvancedOptions = include(
  'src/views/queryFormatter/advancedOptions/AdvancedOptions.js'
);
const { html, If } = include('src/libs/simpleHTML/SimpleHTML.js');
const {
  getQueryInput,
  setQueryInput,
  getQueryOutput,
  getShowAdvancedOptions,
  setShowAdvancedOptions,
  getMaxLineLength,
} = include('src/store/Store.js');

const QueryFormatter = () => {
  const element = html('div', {}, [
    QueryInput(() => ({
      value: getQueryInput(),
      oninput: ({ target }) => setQueryInput(target.value),
    })),
    TextButton(() => ({
      label: getShowAdvancedOptions()
        ? 'Hide advanced options'
        : 'Show advanced options',
      onclick: () => setShowAdvancedOptions(!getShowAdvancedOptions()),
    })),
    html(
      'div',
      () => ({
        style: `max-height: ${
          getShowAdvancedOptions() ? '120px' : '0'
        }; box-shadow: inset white 0 0 10px 0; overflow: hidden; transition: 0.5s;`,
      }),
      [AdvancedOptions()]
    ),
    If(
      () => getQueryOutput(),
      () => [
        Code(() => ({
          innerText: getQueryOutput(),
          maxLineLength: getMaxLineLength(),
        })),
      ]
    ),
  ]);
  return element;
};

module.exports = QueryFormatter;

  return module.exports;
})();

modules['src/app/App.js'] = (() => {
  const module = { exports: {} };
  const Navigator = include('src/components/navigator/Navigator.js');
const StyleGuide = include('src/views/styleGuide/StyleGuide.js');
const QueryFormatter = include('src/views/queryFormatter/QueryFormatter.js');
const LoadingAnimation = include(
  'src/components/loadingAnimation/LoadingAnimation.js'
);
const FadeIn = include('src/components/fadeIn/FadeIn.js');
const { html, If } = include('src/libs/simpleHTML/SimpleHTML.js');
const { getCurrentRoute } = include('src/router/Router.js');

const App = () => {
  let loadingComplete = false;
  const onLoadingComplete = () => {
    loadingComplete = true;
    element.update();
  };
  const element = If(
    () => loadingComplete,
    () => [
      FadeIn(() => ({}), [
        html('div', {}, [
          Navigator(() => ({ currentRoute: getCurrentRoute() })),
          html('div', {}, [
            html(
              'div',
              {
                style:
                  'width: min(800px, 100vw); margin-left: calc(50vw - min(400px, 50vw));',
              },
              [
                If(
                  () => getCurrentRoute() === '/',
                  () => [QueryFormatter(() => ({}))]
                ),
                If(
                  () => getCurrentRoute() === '/style-guide',
                  () => [StyleGuide(() => ({}))]
                ),
              ]
            ),
          ]),
        ]),
      ]),
    ],
    () => [LoadingAnimation(() => ({ onLoadingComplete }))]
  );

  return element;
};

module.exports = App;

  return module.exports;
})();

window.addEventListener('load', () => {
const Observable = include('src/libs/observable/Observable.js');
const App = include('src/app/App.js');
const Store = include('src/store/Store.js');
const Router = include('src/router/Router.js');

const app = App(() => ({}));
Router.addHashChangeListener(app.update);
Store.addQueryInputChangeListener(app.update);
Store.addQueryOutputChangeListener(app.update);
Store.addShowAdvancedOptionsChangeListener(app.update);
Store.addIndentationChangeListener(app.update);
Store.addMaxLineLengthChangeListener(app.update);

Object.assign(document.body.style, {
  fontFamily: 'Sans-Serif',
  margin: '0',
});

document.body.appendChild(app);

})
</script>