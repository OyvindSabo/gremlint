
<script>
const modules = {}
const include = path => modules[path];

modules['src/libs/observable/Observable.js'] = (() => {
  const module = { exports: {} };
  class Observable {
  constructor(value) {
    // Maybe this can cause an id collision of two observables created almost at the same time
    this._id = `${Math.random()}${+new Date()}`;
    this._value = value;
  }
  emit() {
    window.dispatchEvent(
      new CustomEvent(this._id, {
        detail: this._value,
      })
    );
  }
  get id() {
    return this._id;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    // Maybe this should do a deep compare in case value is an object?
    if (value === this._value) return;
    this._value = value;
    this.emit();
  }
}

module.exports = Observable;

  return module.exports;
})();

modules['src/libs/simpleHTML/SimpleHTML.js'] = (() => {
  const module = { exports: {} };
  const doAddInnerShadow = (element) => {
  element.style.boxShadow = 'inset rgba(0, 0, 0, 0.25) 0 0 10px -5px';
};

const doAddShadow = (element) => {
  element.style.boxShadow = 'rgba(0, 0, 0, 0.25) 0 0 10px -5px';
};

const doPatchChildren = (
  element,
  newChildren,
  compareFunction = (a, b) => a === b
) => {
  newChildren.forEach((newChild, index) => {
    // If the new child node already exists on the correct index, jump to next iteration
    if (compareFunction(newChild, element.childNodes[index])) return;

    // As long as there is an old child node at the current index which does not correspond to any of the new childNodes, remove it
    while (
      element.childNodes[index] &&
      !newChildren.some((newChild) =>
        compareFunction(newChild, element.childNodes[index])
      )
    ) {
      element.removeChild(element.childNodes[index]);
    }

    // Insert the new child node at the correct position
    if (element.childNodes[index]) {
      element.insertBefore(newChild, element.childNodes[index]);
      return;
    }
    // TODO: Find out why this is needed
    if (!(newChild.contains && newChild.contains(element))) {
      element.append(newChild);
    }
    return;
  });

  // Remove any superfluous old nodes which don't correspond to the new nodes
  while (newChildren.length < element.childNodes.length) {
    element.removeChild(element.childNodes[newChildren.length]);
  }
};

const flatten = (items) => {
  const flat = [];

  items.forEach((item) => {
    if (Array.isArray(item)) {
      flat.push(...flatten(item));
    } else {
      flat.push(item);
    }
  });

  return flat;
};

const compose = (elementType, getProps, children) => {
  const element = document.createElement(elementType);

  // Assign props
  if (typeof getProps === 'function') {
    Object.assign(element, getProps());
  } else {
    Object.assign(element, getProps);
  }

  // Append children
  element.append(...flatten(children).filter(Boolean));

  element.update = () => {
    // We update the props only if they are provided as a function. Otherwise they are static.
    if (typeof getProps === 'function') {
      if (element.setSelectionRange) {
        const { selectionStart, selectionEnd } = element;
        Object.assign(element, getProps());
        element.setSelectionRange(selectionStart, selectionEnd);
      } else {
        Object.assign(element, getProps());
      }
    }

    Array.from(element.childNodes).forEach((childNode) => {
      // We check that the parent node exists because a previous sibling might
      // be a logic element which has unmounted a later element
      if (typeof childNode.update === 'function' && childNode.parentNode) {
        childNode.update();
      }
    });
  };
  return element;
};

const createContentsContainer = () => {
  const element = Object.assign(document.createElement('div'), {
    style: 'display: contents;',
  });
  return element;
};

const Each = (getArray, mappingFunction) => {
  const logicElement = createContentsContainer();
  let array = getArray();
  const childNodes = flatten(
    array.map((_, i) =>
      mappingFunction(
        () => getArray()[i],
        () => i,
        getArray
      )
    )
  );

  logicElement.append(...childNodes);

  logicElement.update = () => {
    const newArray = getArray();

    if (newArray.length === array.length) {
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
      return;
    }

    // If some elements should be added
    if (newArray.length > array.length) {
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });

      const newChildNodes = flatten(
        newArray.slice(array.length).map((_, _i) => {
          const i = _i + array.length;
          return mappingFunction(
            () => getArray()[i],
            () => i,
            getArray
          );
        })
      );

      logicElement.append(...newChildNodes);

      array = newArray;
      return;
    }

    // If some elements should be removed
    if (newArray.length < array.length) {
      // Even if we already have nodes which can be updated to match the new
      // child nodes, we need to see how many nodes we should keep, since each
      // item in the array can potentially be mapped to several nodes.
      const newChildNodes = flatten(
        newArray.map((_, i) =>
          mappingFunction(
            () => getArray()[i],
            () => i,
            getArray
          )
        )
      );

      // Remove superfluous nodes
      const childrenToBeRemoved = Array.from(logicElement.childNodes).slice(
        newChildNodes.length
      );
      childrenToBeRemoved.forEach((childNodeToBeRemoved) => {
        logicElement.removeChild(childNodeToBeRemoved);
      });

      // Update variables
      array = newArray;

      // Update current child nodes
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
    }
  };

  return logicElement;
};

const If = (getCondition, getThenChildNodes, getElseChildNodes = () => []) => {
  const logicElement = createContentsContainer();
  let condition = getCondition();
  const childNodes = condition
    ? flatten(getThenChildNodes()).filter(Boolean)
    : flatten(getElseChildNodes()).filter(Boolean);

  logicElement.append(...childNodes);

  logicElement.update = () => {
    if (condition && getCondition()) {
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
      return;
    }
    if (!condition && getCondition()) {
      condition = true;
      const thenChildNodes = flatten(getThenChildNodes()).filter(Boolean);
      // Remove the old children
      logicElement.innerHTML = '';

      // Add the new children after the logic element
      logicElement.append(...thenChildNodes);
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
      return;
    }
    if (condition && !getCondition()) {
      condition = false;
      const elseChildNodes = flatten(getElseChildNodes()).filter(Boolean);
      // Remove the old children
      logicElement.innerHTML = '';

      // Add the new children
      logicElement.append(...elseChildNodes);
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
      return;
    }
    Array.from(logicElement.childNodes).forEach((childNode) => {
      if (typeof childNode.update === 'function') {
        childNode.update();
      }
    });
  };
  return logicElement;
};

class SimpleHTML {
  static isProp = (propsOrChild) =>
    !(propsOrChild instanceof HTMLElement || typeof propsOrChild === 'string');
  static makeElement(elementType, propsOrChild, ...maybeAllChildren) {
    const element = document.createElement(elementType);
    const hasProps = SimpleHTML.isProp(propsOrChild);
    const props = hasProps ? propsOrChild || {} : {};
    const children = hasProps
      ? maybeAllChildren
      : [propsOrChild, ...maybeAllChildren];
    Object.entries(props).forEach(([attribute, value]) => {
      if (attribute === 'style') {
        Object.assign(element.style, value);
      } else if (attribute === 'onClick') {
        element.onclick = value;
      } else if (attribute === 'onInput') {
        element.oninput = value;
      } else {
        element[attribute] = value;
      }
    });
    children
      .filter(Boolean)
      .map((child) =>
        typeof child === 'string' ? document.createTextNode(child) : child
      )
      .forEach((child) => {
        element.appendChild(child);
      });
    return element;
  }
}

const doMerge = (oldElement, newElement) => {
  if (!oldElement.parentNode) return;

  const oldChildren = Array.from(oldElement.childNodes);
  const newChildren = Array.from(newElement.childNodes);
  newChildren.forEach((newChild, i) => {
    let foundMatchingOldChild = false;
    while (oldChildren.length && !foundMatchingOldChild) {
      oldChild = oldChildren.shift();
      if (
        oldChild.component === newChild.component &&
        oldChild instanceof Element
      ) {
        const selectionStart = oldChild.selectionStart;
        const selectionEnd = oldChild.selectionEnd;
        oldChild.value = newChild.value;
        oldChild.selectionStart = selectionStart;
        oldChild.selectionEnd = selectionEnd;

        oldChild.update(...newChild.propsAndChildren);
        if (Object.keys(newChild.propsAndChildren[0]).includes('style')) {
          if (!oldChild.style) {
            Object.keys(oldChild.parentNode.style).forEach((property) => {
              if (!newChild.propsAndChildren[0].style[property]) {
                oldChild.parentNode.style[property] = null;
              }
            });
            Object.assign(
              oldChild.parentNode.style,
              newChild.propsAndChildren[0].style
            );
          } else {
            Object.keys(oldChild.parentNode.style).forEach((property) => {
              if (!newChild.propsAndChildren[0].style[property]) {
                oldChild.style[property] = null;
              }
            });
            Object.assign(oldChild.style, newChild.propsAndChildren[0].style);
          }
        }
        oldChild.innerText = newChild.innerText;

        foundMatchingOldChild = true;
      } else if (
        !(oldChild instanceof Element) &&
        !(newChild instanceof Element)
      ) {
        if (oldChild.data === newChild.data) {
          foundMatchingOldChild = true;
        } else {
          oldChild.data = newChild.data;
        }
        foundMatchingOldChild = true;
      } else {
        oldElement.removeChild(oldChild);
      }
    }
    if (!foundMatchingOldChild) {
      while (oldElement.childNodes[i]) {
        oldElement.removeChild(oldElement.childNodes[i]);
      }
      oldElement.appendChild(newChild);
    }
  });
  while (newChildren.length < oldElement.childNodes.length) {
    oldElement.removeChild(oldElement.childNodes[newChildren.length]);
  }
};

const defineComponent = (elementFunction) => {
  const component = (...propsAndChildren) => {
    const element = elementFunction(...propsAndChildren);
    element.component = component;
    element.propsAndChildren = propsAndChildren;
    element.update = (...newPropsAndChildren) => {
      element.propsAndChildren = newPropsAndChildren;
      doMerge(element, component(...newPropsAndChildren));
    };
    return element;
  };
  return component;
};

const div = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('div', props, ...children)
);

const span = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('span', props, ...children)
);

const a = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('a', props, ...children)
);

const p = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('p', props, ...children)
);

const h1 = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('h1', props, ...children)
);

const h2 = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('h2', props, ...children)
);

const img = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('img', props, ...children)
);

const form = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('form', props, ...children)
);

const input = defineComponent((props) =>
  SimpleHTML.makeElement('input', props)
);

const textarea = defineComponent((props) =>
  SimpleHTML.makeElement('textarea', props)
);

const br = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('br', props, ...children)
);

const button = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('button', props, ...children)
);
// And so on, fill in more as needed...

module.exports = {
  doMerge,
  compose,
  Each,
  If,
  defineComponent,
  div,
  span,
  a,
  p,
  h1,
  h2,
  img,
  form,
  input,
  textarea,
  br,
  button,
  doAddInnerShadow,
  doAddShadow,
  doPatchChildren,
};

  return module.exports;
})();

modules['src/libs/simpleRouter/SimpleRouter.js'] = (() => {
  const module = { exports: {} };
  function SimpleRouter(routes) {
  /**
   * @param {string} routes
   */
  this.setRoutes = function (routes) {
    Object.entries(routes).forEach(([route, title]) => {
      this.routes[route] = route;
      this.titles[route] = title;
      if (route === '/') {
        this.routes[''] = route;
        this.titles[''] = title;
      }
    });
    this.syncWithHash();
  };
  SimpleRouter.getTokens = function (hash) {
    return hash
      .split('/')
      .filter(Boolean)
      .filter((element) => element !== '#')
      .filter((element) => element !== '#!');
  };
  /**
   * @param {string} token
   * @returns {boolean}
   */
  SimpleRouter.isParameterRouteToken = function (token) {
    if (
      token.indexOf('<') !== 0 ||
      !token.slice(2, -4).includes(':') ||
      token.indexOf('>') !== token.length - 1
    ) {
      return false;
    }
    const [parameter, type] = token
      .slice(token.indexOf('<') + 1, token.indexOf('>'))
      .split(':');

    if (!['int', 'string', 'number'].includes(type)) {
      return false;
    }
    return true;
  };
  SimpleRouter.appendTokenToHash = function (hash, token) {
    return `${hash}/${token}`;
  };
  SimpleRouter.parseParameterRouteToken = function (token) {
    const [parameter, type] = token
      .slice(token.indexOf('<') + 1, token.indexOf('>'))
      .split(':');
    return {
      parameter,
      type,
    };
  };
  // (hash: string, route: string) => false | { [key: string]: number | string }
  SimpleRouter.getMatch = function (hash, route) {
    const hashTokens = SimpleRouter.getTokens(hash);
    const routeTokens = SimpleRouter.getTokens(route);
    const params = {};
    let reconstructedHash = '#!';
    if (hashTokens.length !== routeTokens.length) return false;
    for (let i of Object.keys(hashTokens)) {
      const hashToken = hashTokens[i];
      const routeToken = routeTokens[i];
      if (SimpleRouter.isParameterRouteToken(routeToken)) {
        const { parameter, type } = SimpleRouter.parseParameterRouteToken(
          routeToken
        );
        if (type === 'int') {
          if (!Router.isInt(hashToken)) return false;
          params[parameter] = parseInt(hashToken);
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        } else if (type === 'number' && !Router.isNumber(hasToken)) {
          if (!Router.isNumber(hashToken)) return false;
          params[parameter] = Number(hashToken);
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        } else if (type === 'string') {
          params[parameter] = hashToken;
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        }
      } else {
        if (hashToken !== routeToken) return false;
        reconstructedHash = SimpleRouter.appendTokenToHash(
          reconstructedHash,
          hashToken
        );
      }
    }
    return { params, reconstructedHash };
  };
  SimpleRouter.getRouteAndParamsFromHash = function (hash, routes) {
    for (let route of Object.keys(routes)) {
      const match = SimpleRouter.getMatch(hash, route);
      if (match) {
        const { params, reconstructedHash } = match;
        return { route, params, reconstructedHash };
      }
    }
    return { route: '', params: {}, reconstructedHash: '' };
  };
  /**
   * @param {Object.<string, number | string>} params
   */
  this.setParams = function (params) {
    this.params = params;
    // Todo: Maybe dispatch some kind of event
  };
  this.setCurrentRoute = function (route) {
    this.currentRoute = route;
  };
  this.setCurrentTitle = function (title) {
    this.currentTitle = title;
  };
  SimpleRouter.removeHash = function () {
    return history.replaceState(null, null, ' ');
  };
  this.syncWithHash = function () {
    const { hash } = location;
    const {
      route,
      params,
      reconstructedHash,
    } = SimpleRouter.getRouteAndParamsFromHash(hash, this.routes);
    this.setParams(params);
    this.setCurrentRoute(this.routes[route]);
    this.setCurrentTitle(this.titles[route]);
    if (reconstructedHash === '#!') {
      SimpleRouter.removeHash();
    } else {
      history.replaceState(undefined, undefined, reconstructedHash);
    }
    document.title = this.currentTitle;
  };
  this.params = {};
  this.currentRoute = '';
  this.routes = {};
  this.titles = {};
  this.hashChangeListeners = [];
  this.setRoutes(routes);
  window.addEventListener('hashchange', () => {
    this.syncWithHash();
    this.callHashChangeListeners();
  });
  /**
   * @param {string} route
   * One of the registered routes, without hashbang
   */
  this.navigateTo = (route) => {
    location.hash = `#!${route}`;
  };

  this.refresh = () => this.syncWithHash();

  // @possiblyNumber: string
  SimpleRouter.isNumber = function (possiblyNumber) {
    return !isNaN(Number(possiblyNumber));
  };
  SimpleRouter.isInt = function (possiblyInt) {
    return (
      SimpleRouter.isNumber(possiblyInt) &&
      parseInt(possiblyInt) === Number(possiblyInt)
    );
  };
  this.addHashChangeListener = (callback) => {
    this.hashChangeListeners.push(callback);
    this.callHashChangeListeners();
  };
  this.callHashChangeListeners = () => {
    this.hashChangeListeners.forEach((hashChangeListener) =>
      hashChangeListener({
        params: this.params,
        currentRoute: this.currentRoute,
      })
    );
  };
  this.getParams = () => this.params;
  this.getCurrentTitle = () => this.currentTitle;
  SimpleRouter.isProp = (propsOrChild) =>
    !(propsOrChild instanceof HTMLElement || typeof propsOrChild === 'string');
}

module.exports = SimpleRouter;

  return module.exports;
})();

modules['src/router/Router.js'] = (() => {
  const module = { exports: {} };
  const SimpleRouter = include('src/libs/simpleRouter/SimpleRouter.js');

const router = new SimpleRouter({
  '/': 'Gremlint - Gremlin query formatter',
  '/style-guide': 'Gremlint - Style guide',
});

const getCurrentRoute = () => router.currentRoute;
const addHashChangeListener = (hashChangeListener) => {
  router.addHashChangeListener(hashChangeListener);
};

module.exports = {
  getCurrentRoute,
  addHashChangeListener,
};

  return module.exports;
})();

modules['src/libs/simpleColorPalette/SimpleColorPalette.js'] = (() => {
  const module = { exports: {} };
  const TextColor = 'slategray';
const HighlightedTextColor = 'darkslategray';
const DisabledTextColor = 'lightgray';
const HighlightColor = 'yellowgreen';
const White = 'white';

module.exports = {
  TextColor,
  HighlightedTextColor,
  DisabledTextColor,
  HighlightColor,
  White,
};

  return module.exports;
})();

modules['src/components/navigationButton/NavigationButton.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libs/simpleHTML/SimpleHTML.js');
const { HighlightedTextColor, TextColor, HighlightColor } = include(
  'src/libs/simpleColorPalette/SimpleColorPalette.js'
);

const NavigationButton = (getProps) => {
  const getIsSelected = () => getProps().isSelected;
  const getHref = () => getProps().href;
  const getLabel = () => getProps().label;

  let isHovered = false;
  const getIsHovered = () => isHovered;
  const setIsHovered = (value) => {
    isHovered = value;
    element.update();
  };

  const getSpanStyle = () => `
    display: inline-block;
    padding: 10px;
    box-sizing: border-box;
    width: 140px;
  `;

  const getAStyle = () => `
    text-decoration: none;
    display: inline-block;
    height: 20px;
    line-height: 20px;
    font-size: 15px;
    color: ${
      getIsSelected() || getIsHovered() ? HighlightedTextColor : TextColor
    };
    border-bottom: ${getIsSelected() ? `2px solid ${HighlightColor}` : 'none'};
  `;

  const element = compose('span', () => ({ style: getSpanStyle() }), [
    compose(
      'a',
      () => ({
        href: getHref(),
        innerText: getLabel(),
        style: getAStyle(),
        onmouseenter: () => setIsHovered(true),
        onmouseleave: () => setIsHovered(false),
      }),
      []
    ),
  ]);

  return element;
};

module.exports = NavigationButton;

  return module.exports;
})();

modules['src/components/navigator/Navigator.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libs/simpleHTML/SimpleHTML.js');
const { White } = include('src/libs/simpleColorPalette/SimpleColorPalette.js');
const NavigationButton = include(
  'src/components/navigationButton/NavigationButton.js'
);

const getQueryFormatterButtonProps = (getCurrentRoute) => () => ({
  isSelected: getCurrentRoute() === '/',
  label: 'Query formatter',
  href: '#!/',
});

const getStyleGuideButtonProps = (getCurrentRoute) => () => ({
  isSelected: getCurrentRoute() === '/style-guide',
  label: 'Style guide',
  href: '#!/style-guide',
});

const Navigator = (getProps) => {
  const getCurrentRoute = () => getProps().currentRoute;
  const element = compose('div', {}, [
    compose(
      'div',
      {
        style: `background: ${White};
                box-shadow: ${White} 0 0 10px;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;`,
      },
      [
        compose(
          'div',
          { style: 'width: 800px; margin-left: calc(50vw - 400px);' },
          [
            NavigationButton(getQueryFormatterButtonProps(getCurrentRoute)),
            NavigationButton(getStyleGuideButtonProps(getCurrentRoute)),
          ]
        ),
      ]
    ),
    compose('div', { style: 'height:40px;' }, []),
  ]);
  return element;
};

module.exports = Navigator;

  return module.exports;
})();

modules['src/views/styleGuide/rules/Rules.js'] = (() => {
  const module = { exports: {} };
  const rules = [
  {
    title: 'Break long queries into multiple lines',
    explanation: `What is considered too long depends on your application.

When breaking the query, not all parts of the traversal have to be broken up. First, divide the query into logical groups, based on which steps belong naturally together. For instance, every set of steps which end with an as()-step often belong together, as they together form a new essential step in the query.
    
If anoymous traversals are passed as arguments to another step, like a filter()-step, and it's causing the line to be too long, first split the line at the commas. Only if the traversal arguments are still too long, consider splitting them further.`,
    example: `// Good (80 characters max width)
g.V().hasLabel('person').where(outE("created").count().is(P.gte(2))).count()
    
// Good (50 characters max width)
g.V().
  hasLabel('person').
  where(outE("created").count().is(P.gte(2))).
  count()
    
// Good (30 characters max width)
g.V().
  hasLabel('person').
  where(
    outE("created").
    count().
    is(P.gte(2))).
  count()`,
  },
  {
    title: 'Use soft tabs (spaces) for indentation',
    explanation:
      'This ensures that your code looks the same for anyone, regardless of their text editor settings.',
    example: `// Bad - indented using hard tabs
g.V().
  hasLabel('person').as('person').
  properties('location').as('location').
  select('person','location').
    by('name').
    by(valueMap())
    
// Good - indented using spaces
g.V().
∙∙hasLabel('person').as('person').
∙∙properties('location').as('location').
∙∙select('person','location').
∙∙∙∙by('name').
∙∙∙∙by(valueMap())`,
  },
  {
    title: 'Use two spaces for indentation',
    explanation:
      'Two spaces makes the intent of the indent clear, but does not waste too much space. Of course, more spaces are allowed when indenting from an already indented block of code.',
    example: `// Bad - Indented using four spaces
g.V().
    hasLabel('person').as('person').
    properties('location').as('location').
    select('person','location').
        by('name').
        by(valueMap())

// Good - Indented using two spaces
g.V().
  hasLabel('person').as('person').
  properties('location').as('location').
  select('person','location').
    by('name').
    by(valueMap())`,
  },
  {
    title: 'Use indents wisely',
    explanation: `No newline should ever have the same indent as the line starting with the traversal source g.

Use indents when the step in the new line is a modulator of a previous line.

Use indents when the content in the new line is an argument of a previous step.

If multiple anonymous traversals are passed as arguments to a function, each newline which is not the first step of the traversal should be indented to make it more clear where the distinction between each argument goes. If this is the case, but the newline would already be indented because the step in the content in the new line is the argument of a previous step, there is no need to double-indent.

Don't be tempted to add extra indentation to vertically align a step with a step in a previous line.`,
    example: `// Bad - No newline should have the same indent as the line starting with the traversal source g
g.V().
group().
by().
by(bothE().count())

// Bad - Modulators of a step on a previous line should be indented
g.V().
  group().
  by().
  by(bothE().count())

// Good
g.V().
  group().
    by().
    by(bothE().count())

// Bad - You have ignored the indent rules to achieve the temporary satisfaction of vertical alignment
g.V().local(union(identity(),
                  bothE().count()).
            fold())

// Good
g.V().
  local(
    union(
      identity(),
      bothE().count()).
    fold())

// Bad - When multiple anonymous traversals are passed as arguments to a function, each newline which is not the first of line of the step should be indented to make it more clear where the distinction between each argument goes.
g.V().
  has('person','name','marko').
  fold().
  coalesce(
    unfold(),
    addV('person').
    property('name','marko').
    property('age',29))

// Good - We make it clear that the coalesce step takes two traversals as arguments
g.V().
  has('person','name','marko').
  fold().
  coalesce(
    unfold(),
    addV('person').
      property('name','marko').
      property('age',29))`,
  },
  {
    title: 'Keep as()-steps at the end of each line',
    explanation: `The end of the line is a natural place to assign a label to a step. It's okay if the as()-step is in the middle of the line if there are multiple consecutive label assignments, or if the line is so short that a newline doesn't make sense. Maybe a better way to put it is to not start a line with an as()-step, unless you're using it inside a match()-step of course.`,
    example: `// Bad
g.V().
  as('a').
  out('created').
  as('b').
  select('a','b')

// Good
g.V().as('a').
  out('created').as('b').
  select('a','b')

// Good
g.V().as('a').out('created').as('b').select('a','b')`,
  },
  {
    title: 'Add linebreak after punctuation, not before',
    explanation: `While adding the linebreak before the punctuation looks good in most cases, it introduces alignment problems when not all lines start with a punctuation. You never know if the next line should be indented relative to the punctuation of the previous line or the method of the previous line. Switching between having the punctuation at the start or the end of the line depending on whether it works in a particular case requires much brainpower (which we don't have), so it's better to be consistent. Adding the punctuation before the linebreak also means that you can know if you have reached the end of the query without reading the next line.`,
    example: `// Bad - Looks okay, though
g.V().has('name','marko')
     .out('knows')
     .has('age', gt(29))
     .values('name')

// Good
g.V().
  has('name','marko').
  out('knows').
  has('age', gt(29)).
  values('name')

// Bad - Punctuation at the start of the line makes the transition from filter to select to count too smooth
g.V()
  .hasLabel("person")
  .group()
    .by(values("name", "age").fold())
  .unfold()
  .filter(
    select(values)
    .count(local)
    .is(gt(1)))

// Good - Keeping punctuation at the end of each line, more clearly shows the query structure
g.V().
  hasLabel("person").
  group().
    by(values("name", "age").fold()).
  unfold().
  filter(
    select(values).
    count(local).
    is(gt(1)))`,
  },
  {
    title:
      'Add linebreak and indentation for nested traversals which are long enough to span multiple lines',
    explanation: '',
    example: `// Bad - Not newlining the first argument of a function whose arguments span over multipe lines causes the arguments to not align.
g.V().
  hasLabel("person").
  groupCount().
    by(values("age").
      choose(is(lt(28)),
        constant("young"),
        choose(is(lt(30)),
          constant("old"),
          constant("very old"))))

// Bad - We talked about this in the indentation section, didn't we?
g.V().
  hasLabel("person").
  groupCount().
    by(values("age").
       choose(is(lt(28)),
              constant("young"),
              choose(is(lt(30)),
                     constant("old"),
                     constant("very old"))))

// Good
g.V().
  hasLabel("person").
  groupCount().
    by(
      values("age").
      choose(
        is(lt(28)),
        constant("young"),
        choose(
          is(lt(30)),
          constant("old"),
          constant("very old"))))`,
  },
  {
    title:
      'Place all trailing parentheses on a single line instead of distinct lines',
    explanation:
      'Aligning the end parenthesis with the step to which the start parenthesis belongs might make it easier to check that the number of parentheses is correct, but looks ugly and wastes a lot of space.',
    example: `// Bad
g.V().
  hasLabel("person").
  groupCount().
    by(
      values("age").
      choose(
        is(lt(28)),
        constant("young"),
        choose(
          is(lt(30)),
          constant("old"),
          constant("very old")
        )
      )
    )

// Good
g.V().
  hasLabel("person").
  groupCount().
    by(
      values("age").
      choose(
        is(lt(28)),
        constant("young"),
        choose(
          is(lt(30)),
          constant("old"),
          constant("very old"))))`,
  },
  {
    title:
      'Use // for single line comments. Place single line comments on a newline above the subject of the comment.',
    explanation: '',
    example: `// Bad
g.V().
  has('name','alice').out('bought'). // Find everything that Alice has bought
  in('bought').dedup().values('name') // Find everyone who have bought some of the same things as Alice

// Good
g.V().
  // Find everything that Alice has bought
  has('name','alice').out('bought').
  // Find everyone who have bought some of the same things as Alice
  in('bought').dedup().values('name')`,
  },
  {
    title: 'Use single quotes for strings',
    explanation:
      'Use single quotes for literal string values. If the string contains double quotes or single quotes, surround the string with the type of quote which creates the fewest escaped characters.',
    example: `// Bad - Use single quotes where possible
g.V().has("Movie", "name", "It's a wonderful life")

// Bad - Escaped single quotes are even worse than double quotes
g.V().has('Movie', 'name', 'It\'s a wonderful life')

// Good
g.V().has('Movie', 'name', "It's a wonderful life")`,
  },
  {
    title: 'Write idiomatic Gremlin code',
    explanation: `If there is a simpler way, do it the simpler way. Use the Gremlin methods for what they're worth.`,
    example: `// Bad
g.V().outE().inV()

// Good
g.V().out()


// Bad
g.V().
  has('name', 'alice').
  outE().hasLabel('bought').inV().
  values('name')

// Good
g.V().
  has('name','alice').
  out('bought').
  values('name')


// Bad
g.V().hasLabel('person').has('name', 'alice')

// Good
g.V().has('person', 'name', 'alice')`,
  },
];

module.exports = { rules };

  return module.exports;
})();

modules['src/components/queryInput/QueryInput.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libs/simpleHTML/SimpleHTML.js');

const getQueryInputStyle = () => `
  height: calc(50vh - 60px);
  border-radius: 5px;
  font-family: "Courier New", Courier, monospace;
  background: rgba(0, 0, 0, 0.05);
  outline: none;
  font-size: 15px;
  padding: 10px;
  border: none;
  resize: none;
  width: 100%;
  box-shadow: inset rgba(0, 0, 0, 0.5) 0 0 10px -5px;
`;

const QueryInput = (getProps) => {
  const getOnInput = () => getProps().oninput;
  const getValue = () => getProps().value;
  return compose('div', { style: 'padding: 10px;' }, [
    compose(
      'textarea',
      () => ({
        oninput: getOnInput(),
        style: getQueryInputStyle(),
        value: getValue(),
      }),
      []
    ),
  ]);
};

module.exports = QueryInput;

  return module.exports;
})();

modules['src/components/code/Code.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libs/simpleHTML/SimpleHTML.js');
const { TextColor } = include(
  'src/libs/simpleColorPalette/SimpleColorPalette.js'
);

const getCodeStyle = () => `
  border-radius: 5px;
  font-family: "Courier New", Courier, monospace;
  background: rgba(0, 0, 0, 0.05);
  outline: none;
  font-size: 15px;
  padding: 10px;
  border: none;
  resize: none;
  box-shadow: inset rgba(0, 0, 0, 0.5) 0 0 10px -5px;
  white-space: pre-wrap;
`;

const Code = (getProps) => {
  const getInnerText = () => getProps().innerText;
  const element = compose('div', { style: 'padding: 10px;' }, [
    compose('div', { style: getCodeStyle() }, [
      compose(
        'span',
        () => ({
          style: `color: ${TextColor}; line-height: 20px; font-size: 15px;`,
          innerText: getInnerText(),
        }),
        []
      ),
    ]),
  ]);
  return element;
};

module.exports = Code;

  return module.exports;
})();

modules['src/components/textButton/TextButton.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libs/simpleHTML/SimpleHTML.js');
const { HighlightedTextColor, TextColor } = include(
  'src/libs/simpleColorPalette/SimpleColorPalette.js'
);

const TextButton = (getProps) => {
  const getHref = () => getProps().href;
  const getLabel = () => getProps().label;
  const getOnClick = () => getProps().onclick;

  let isHovered = false;
  const getIsHovered = () => isHovered;
  const setIsHovered = (value) => {
    isHovered = value;
    element.update();
  };

  const getSpanStyle = () => `
    display: inline-block;
    padding: 10px;
    box-sizing: border-box;
  `;

  const getButtonStyle = () => `
    text-decoration: none;
    display: inline-block;
    height: 20px;
    line-height: 20px;
    font-size: 15px;
    color: ${getIsHovered() ? HighlightedTextColor : TextColor};
    background: none;
    border: none;
    padding: 0;
  `;

  const element = compose('span', () => ({ style: getSpanStyle() }), [
    compose(
      'button',
      () => ({
        href: getHref(),
        innerText: getLabel(),
        style: getButtonStyle(),
        onmouseenter: () => setIsHovered(true),
        onmouseleave: () => setIsHovered(false),
        onclick: getOnClick(),
      }),
      []
    ),
  ]);

  return element;
};

module.exports = TextButton;

  return module.exports;
})();

modules['src/libs/simpleFP/SimpleFP.js'] = (() => {
  const module = { exports: {} };
  const last = (array) => array.slice(-1)[0];

const pipe = (...fns) => (value) => fns.reduce((value, fn) => fn(value), value);

module.exports = { last, pipe };

  return module.exports;
})();

modules['src/libs/gremlint/parseToSyntaxTree/ParseToSyntaxTree.js'] = (() => {
  const module = { exports: {} };
  const { last, pipe } = include('src/libs/simpleFP/SimpleFP.js');

const tokenizeOnTopLevelPunctuation = (query) => {
  word = '';
  parenthesesCount = 0;
  squareBracketCount = 0;
  curlyBracketCount = 0;
  isInsideSingleQuoteString = false;
  query.split('').forEach((char) => {
    if (char === '(' && !isInsideSingleQuoteString) {
      parenthesesCount++;
      word += '(';
      return;
    }
    if (char === '[' && !isInsideSingleQuoteString) {
      squareBracketCount++;
      word += '[';
      return;
    }
    if (char === '{' && !isInsideSingleQuoteString) {
      curlyBracketCount++;
      word += '{';
      return;
    }
    if (char === ')' && !isInsideSingleQuoteString) {
      parenthesesCount--;
      word += ')';
      return;
    }
    if (char === ']' && !isInsideSingleQuoteString) {
      squareBracketCount--;
      word += ']';
      return;
    }
    if (char === '}' && !isInsideSingleQuoteString) {
      curlyBracketCount--;
      word += '}';
      return;
    }
    if (char === "'") {
      isInsideString = !isInsideSingleQuoteString;
      word += "'";
      return;
    }
    if (char === '.') {
      word +=
        isInsideSingleQuoteString ||
        parenthesesCount ||
        squareBracketCount ||
        curlyBracketCount
          ? '.'
          : String.fromCharCode(28);
      return;
    }
    word += char;
  });
  return word
    .split(String.fromCharCode(28))
    .filter((token) => token !== '')
    .map((token) => token.trim());
};

const tokenizeOnTopLevelComma = (query) => {
  word = '';
  parenthesesCount = 0;
  squareBracketCount = 0;
  curlyBracketCount = 0;
  isInsideSingleQuoteString = false;
  query.split('').forEach((char) => {
    if (char === '(' && !isInsideSingleQuoteString) {
      parenthesesCount++;
      word += '(';
      return;
    }
    if (char === '[' && !isInsideSingleQuoteString) {
      squareBracketCount++;
      word += '[';
      return;
    }
    if (char === '{' && !isInsideSingleQuoteString) {
      curlyBracketCount++;
      word += '{';
      return;
    }
    if (char === ')' && !isInsideSingleQuoteString) {
      parenthesesCount--;
      word += ')';
      return;
    }
    if (char === ']' && !isInsideSingleQuoteString) {
      squareBracketCount--;
      word += ']';
      return;
    }
    if (char === '}' && !isInsideSingleQuoteString) {
      curlyBracketCount--;
      word += '}';
      return;
    }
    if (char === "'") {
      isInsideString = !isInsideSingleQuoteString;
      word += "'";
      return;
    }
    if (char === ',') {
      word +=
        isInsideSingleQuoteString ||
        parenthesesCount ||
        squareBracketCount ||
        curlyBracketCount
          ? ','
          : String.fromCharCode(28);
      return;
    }
    word += char;
  });
  return word
    .split(String.fromCharCode(28))
    .filter((token) => token !== '')
    .map((token) => token.trim());
};

const tokenizeOnTopLevelParentheses = (query) => {
  word = '';
  parenthesesCount = 0;
  squareBracketCount = 0;
  curlyBracketCount = 0;
  isInsideSingleQuoteString = false;
  query.split('').forEach((char) => {
    if (char === '(' && !isInsideSingleQuoteString) {
      if (parenthesesCount === 0) {
        word += String.fromCharCode(28);
      }
      parenthesesCount++;
      word += '(';
      return;
    }
    if (char === '[' && !isInsideSingleQuoteString) {
      squareBracketCount++;
      word += '[';
      return;
    }
    if (char === '{' && !isInsideSingleQuoteString) {
      curlyBracketCount++;
      word += '{';
      return;
    }
    if (char === ')' && !isInsideSingleQuoteString) {
      parenthesesCount--;
      word += ')';
      return;
    }
    if (char === ']' && !isInsideSingleQuoteString) {
      squareBracketCount--;
      word += ']';
      return;
    }
    if (char === '}' && !isInsideSingleQuoteString) {
      curlyBracketCount--;
      word += '}';
      return;
    }
    if (char === "'") {
      isInsideString = !isInsideSingleQuoteString;
      word += "'";
      return;
    }
    word += char;
  });
  return word
    .split(String.fromCharCode(28))
    .filter((token) => token !== '')
    .map((token) => token.trim());
};

const isWrappedInParentheses = (token) => {
  if (token.length < 2) return false;
  if (token.charAt(0) !== '(') return false;
  if (token.slice(-1) !== ')') return false;
  return true;
};

const isString = (token) => {
  if (token.length < 2) return false;
  if (token.charAt(0) !== token.substr(-1)) return false;
  if (['"', "'"].includes(token.charAt(0))) return true;
  return false;
};

const isMethodInvocation = (token) => {
  return pipe(
    tokenizeOnTopLevelParentheses,
    last,
    isWrappedInParentheses
  )(token);
};

const trimParentheses = (expression) => expression.slice(1, -1);

const getMethodTokenAndArgumentTokensFromMethodInvocation = (token) => {
  // The word before the first parenthesis is the method name
  // The token may be a double application of a curried function, so we cannot
  // assume that the first opening parenthesis is closed by the last closing
  // parenthesis
  const tokens = tokenizeOnTopLevelParentheses(token);
  return {
    methodToken: tokens.slice(0, -1).join(''),
    argumentTokens: pipe(
      trimParentheses,
      tokenizeOnTopLevelComma
    )(tokens.slice(-1)[0]),
  };
};

const tokenize = pipe(tokenizeOnTopLevelPunctuation);

const parseToSyntaxTree = (query) => {
  const tokens = tokenizeOnTopLevelPunctuation(query);
  if (tokens.length === 1) {
    const token = tokens[0];
    if (isMethodInvocation(token)) {
      const {
        methodToken,
        argumentTokens,
      } = getMethodTokenAndArgumentTokensFromMethodInvocation(token);
      return {
        type: 'method',
        method: parseToSyntaxTree(methodToken),
        arguments: argumentTokens.map(parseToSyntaxTree),
      };
    }
    if (isString(token)) {
      return {
        type: 'string',
        string: token,
      };
    }
    return {
      type: 'word',
      word: token,
    };
  }
  return {
    type: 'traversal',
    steps: tokens.map(parseToSyntaxTree),
  };
};

module.exports = {
  parseToSyntaxTree,
};

  return module.exports;
})();

modules['src/components/title/Title.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libs/simpleHTML/SimpleHTML.js');
const { TextColor } = include(
  'src/libs/simpleColorPalette/SimpleColorPalette.js'
);

const Title = (getProps) => {
  const getInnerText = () => getProps().innerText;
  const element = compose(
    'div',
    { style: getInnerText() ? 'padding: 10px;' : '' },
    [
      compose(
        'span',
        {
          style: `color: ${TextColor}; line-height: 30px; font-size: 25px;`,
          innerText: getInnerText(),
        },
        []
      ),
    ]
  );
  return element;
};

module.exports = Title;

  return module.exports;
})();

modules['src/components/paragraph/Paragraph.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libs/simpleHTML/SimpleHTML.js');
const { TextColor } = include(
  'src/libs/simpleColorPalette/SimpleColorPalette.js'
);

const Paragraph = (getProps) => {
  const getInnerText = () => getProps().innerText;
  const element = compose(
    'div',
    () => ({ style: getInnerText() ? 'padding: 10px;' : '' }),
    [
      compose(
        'span',
        {
          style: `color: ${TextColor}; line-height: 20px; font-size: 15px;`,
          innerText: getInnerText(),
        },
        []
      ),
    ]
  );
  return element;
};

module.exports = Paragraph;

  return module.exports;
})();

modules['src/components/spacer/Spacer.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libs/simpleHTML/SimpleHTML.js');

const Spacer = () => compose('div', { style: 'height: 20px' }, []);

module.exports = Spacer;

  return module.exports;
})();

modules['src/components/styleGuideRule/StyleGuideRule.js'] = (() => {
  const module = { exports: {} };
  const Title = include('src/components/title/Title.js');
const Paragraph = include('src/components/paragraph/Paragraph.js');
const Code = include('src/components/code/Code.js');
const Spacer = include('src/components/spacer/Spacer.js');
const { compose } = include('src/libs/simpleHTML/SimpleHTML.js');

const StyleGuideRule = (getProps) => {
  const getTitle = () => getProps().title;
  const getExplanation = () => getProps().explanation;
  const getExample = () => getProps().example;

  return compose('div', {}, [
    Title(() => ({ innerText: getTitle() })),
    Paragraph(() => ({ innerText: getExplanation() })),
    Code(() => ({ innerText: getExample() })),
    Spacer(() => ({})),
  ]);
};

module.exports = StyleGuideRule;

  return module.exports;
})();

modules['src/views/styleGuide/StyleGuide.js'] = (() => {
  const module = { exports: {} };
  const StyleGuideRule = include(
  'src/components/styleGuideRule/StyleGuideRule.js'
);
const { compose, Each } = include('src/libs/simpleHTML/SimpleHTML.js');
const { rules } = include('src/views/styleGuide/rules/Rules.js');

const StyleGuide = () =>
  compose('div', {}, [
    Each(
      () => rules,
      (getCurrentValue) => [
        StyleGuideRule(() => ({
          title: getCurrentValue().title,
          explanation: getCurrentValue().explanation,
          example: getCurrentValue().example,
        })),
      ]
    ),
  ]);

module.exports = StyleGuide;

  return module.exports;
})();

modules['src/libs/gremlint/utils.js'] = (() => {
  const module = { exports: {} };
  const spaces = (numberOfSpaces) => Array(numberOfSpaces + 1).join(' ');

module.exports = {
  spaces,
};

  return module.exports;
})();

modules['src/libs/gremlint/recreateQueryStringFromFormattedSyntaxTree/RecreateQueryStringFromFormattedSyntaxTree.js'] = (() => {
  const module = { exports: {} };
  const { spaces } = include('src/libs/gremlint/utils.js');

const recreateQueryStringFromFormattedSyntaxTree = (syntaxTree) => {
  if (syntaxTree.type === 'traversal') {
    console.log('syntaxTree.stepGroups: ', syntaxTree.stepGroups);
    return syntaxTree.stepGroups
      .map((stepGroup) =>
        stepGroup.steps
          .map(recreateQueryStringFromFormattedSyntaxTree)
          .join('.')
      )
      .join('.\n');
  }
  if (syntaxTree.type === 'method') {
    return [
      recreateQueryStringFromFormattedSyntaxTree(syntaxTree.method) + '(',
      syntaxTree.argumentGroups
        .map((arguments) =>
          arguments.map(recreateQueryStringFromFormattedSyntaxTree).join(', ')
        )
        .join(',\n') + ')',
    ].join(syntaxTree.argumentsShouldStartOnNewLine ? '\n' : '');
  }
  if (syntaxTree.type === 'string') {
    return spaces(syntaxTree.indentation) + syntaxTree.string;
  }
  if (syntaxTree.type === 'word') {
    return spaces(syntaxTree.indentation) + syntaxTree.word;
  }
};

module.exports = {
  recreateQueryStringFromFormattedSyntaxTree,
};

  return module.exports;
})();

modules['src/libs/gremlint/recreateQueryOnelinerFromSyntaxTree/RecreateQueryOnelinerFromSyntaxTree.js'] = (() => {
  const module = { exports: {} };
  const { spaces } = include('src/libs/gremlint/utils.js');

const recreateQueryOnelinerFromSyntaxTree = (indentation = 0) => (
  syntaxTree
) => {
  switch (syntaxTree.type) {
    case 'traversal':
      return (
        spaces(indentation) +
        syntaxTree.steps.map(recreateQueryOnelinerFromSyntaxTree()).join('.')
      );
    case 'method':
      return (
        spaces(indentation) +
        recreateQueryOnelinerFromSyntaxTree()(syntaxTree.method) +
        '(' +
        syntaxTree.arguments
          .map(recreateQueryOnelinerFromSyntaxTree())
          .join(', ') +
        ')'
      );
    case 'string':
      return spaces(indentation) + syntaxTree.string;
    case 'word':
      return spaces(indentation) + syntaxTree.word;
  }
};

module.exports = {
  recreateQueryOnelinerFromSyntaxTree,
};

  return module.exports;
})();

modules['src/libs/gremlint/formatSyntaxTree/FormatSyntaxTree.js'] = (() => {
  const module = { exports: {} };
  const { recreateQueryOnelinerFromSyntaxTree } = include(
  'src/libs/gremlint/recreateQueryOnelinerFromSyntaxTree/RecreateQueryOnelinerFromSyntaxTree.js'
);

const isTraversalSource = (step) => step.type === 'word' && step.word === 'g';

const isModulator = (step) =>
  step.type === 'method' &&
  step.method.type === 'word' &&
  step.method.word === 'by';

const withIndentation = (config, indentation) => ({ ...config, indentation });

const withZeroIndentation = (config) => withIndentation(config, 0);

const withIncreasedIndentation = (config, indentationIncrease) => ({
  ...config,
  indentation: config.indentation + indentationIncrease,
});

const getStepGroups = (steps, config) => {
  const { stepGroups } = steps.reduce(
    ({ stepsInStepGroup, stepGroups }, step, index, steps) => {
      // TODO: We need to make sure that indentation is zero for all steps which are not the first in the step group
      // If it should be the last step in a line
      if (step.type === 'method' || index === steps.length - 1) {
        // If it is the first step, format it with indentation, otherwise, remove the indentation
        if (!stepsInStepGroup.length) {
          return {
            stepsInStepGroup: [],
            stepGroups: [
              ...stepGroups,
              // TODO: Here, the indentation should be increased if the current step group is a modulator of the previous stepGroup. Anything is a modulator of a stepGroup which contains the word g. Other modulators, like as and by will have to be hard coded.
              {
                steps: [
                  formatSyntaxTree(
                    withIncreasedIndentation(
                      config,
                      (stepGroups[0] &&
                      isTraversalSource(stepGroups[0].steps[0])
                        ? 2
                        : 0) + (isModulator(step) ? 2 : 0)
                    )
                  )(step),
                ],
              },
            ],
          };
        }
        return {
          stepsInStepGroup: [],
          stepGroups: [
            ...stepGroups,
            // TODO: Here, the indentation should be increased if the current step group is a modulator of the previous stepGroup. Anything is a modulator of a stepGroup which contains the word g. Other modulators, like as and by will have to be hard coded.
            {
              steps: [
                ...stepsInStepGroup,
                formatSyntaxTree(withZeroIndentation(config))(step),
              ],
            },
          ],
        };
      } else {
        // If it is the first step, format it with indentation, otherwise, remove the indentation
        if (!stepsInStepGroup.length) {
          return {
            stepsInStepGroup: [formatSyntaxTree(config)(step)],
            stepGroups,
          };
        }
        return {
          stepsInStepGroup: [
            ...stepsInStepGroup,
            formatSyntaxTree(withZeroIndentation(config))(step),
          ],
          stepGroups,
        };
      }
    },
    { stepsInStepGroup: [], stepGroups: [] }
  );
  return stepGroups;
};

// Groups steps into stepGroups and argumentGroups respectively and adds an indentation property
// TODO: Rewrite RecreateQueryStringFromFormattedSyntaxTree to support this
const formatSyntaxTree = (config) => (syntaxTree) => {
  const recreatedQuery = recreateQueryOnelinerFromSyntaxTree(
    config.indentation
  )(syntaxTree);
  if (syntaxTree.type === 'traversal') {
    return recreatedQuery.length <= config.maxLineLength
      ? {
          type: 'traversal',
          stepGroups: [
            {
              steps: syntaxTree.steps.map((step, index) =>
                formatSyntaxTree(
                  index === 0 ? config : withZeroIndentation(config)
                )(step)
              ),
            },
          ],
        }
      : {
          type: 'traversal',
          stepGroups: getStepGroups(syntaxTree.steps, config),
        };
  }

  if (syntaxTree.type === 'method') {
    return recreatedQuery.length <= config.maxLineLength
      ? {
          type: 'method',
          method: formatSyntaxTree(config)(syntaxTree.method),
          argumentGroups: [
            syntaxTree.arguments.map((step) =>
              formatSyntaxTree(withZeroIndentation(config))(step)
            ),
          ],
          argumentsShouldStartOnNewLine: false,
        }
      : {
          type: 'method',
          method: formatSyntaxTree(config)(syntaxTree.method),
          argumentGroups: syntaxTree.arguments.map((step) => [
            formatSyntaxTree(withIncreasedIndentation(config, 2))(step),
          ]),
          argumentsShouldStartOnNewLine: true,
        };
  }
  if (syntaxTree.type === 'string') {
    return {
      type: 'string',
      string: syntaxTree.string,
      indentation: config.indentation,
    };
  }
  if (syntaxTree.type === 'word') {
    return {
      type: 'word',
      word: syntaxTree.word,
      indentation: config.indentation,
    };
  }
};

module.exports = { formatSyntaxTree };

  return module.exports;
})();

modules['src/libs/gremlint/Gremlint.js'] = (() => {
  const module = { exports: {} };
  const { pipe } = include('src/libs/simpleFP/SimpleFP.js');
const { parseToSyntaxTree } = include(
  'src/libs/gremlint/parseToSyntaxTree/ParseToSyntaxTree.js'
);
const { formatSyntaxTree } = include(
  'src/libs/gremlint/formatSyntaxTree/FormatSyntaxTree.js'
);
const { recreateQueryStringFromFormattedSyntaxTree } = include(
  'src/libs/gremlint/recreateQueryStringFromFormattedSyntaxTree/RecreateQueryStringFromFormattedSyntaxTree.js'
);

const formatQuery = (query, config = { indentation: 0, maxLineLength: 80 }) => {
  console.log(
    'formattedSyntaxTree',
    pipe(parseToSyntaxTree, formatSyntaxTree(config))(query)
  );
  return pipe(
    parseToSyntaxTree,
    formatSyntaxTree(config),
    recreateQueryStringFromFormattedSyntaxTree
  )(query);
};

module.exports = {
  formatQuery,
};

  return module.exports;
})();

modules['src/store/Store.js'] = (() => {
  const module = { exports: {} };
  const Observable = include('src/libs/observable/Observable.js');
const { formatQuery } = include('src/libs/gremlint/Gremlint.js');

// Query input state
const queryInput$ = new Observable('');
const getQueryInput = () => queryInput$.value;
const setQueryInput = (queryInput) => {
  queryInput$.value = queryInput;
};
const addQueryInputChangeListener = (callback) => {
  addEventListener(queryInput$.id, callback);
};

// Query output state
const queryOutput$ = new Observable('');
const getQueryOutput = () => queryOutput$.value;
const setQueryOutput = (queryOutput) => {
  queryOutput$.value = queryOutput;
};
const addQueryOutputChangeListener = (callback) => {
  addEventListener(queryOutput$.id, callback);
};

// Show advanced options state
const showAdvancedOptions$ = new Observable(false);
const getShowAdvancedOptions = () => showAdvancedOptions$.value;
const setShowAdvancedOptions = (showAdvancedOptions) => {
  console.log('setting');
  showAdvancedOptions$.value = showAdvancedOptions;
};
const addShowAdvancedOptionsChangeListener = (callback) => {
  addEventListener(showAdvancedOptions$.id, callback);
};

addQueryInputChangeListener(({ detail }) => {
  setQueryOutput(formatQuery(detail));
});

module.exports = {
  getQueryInput,
  setQueryInput,
  addQueryInputChangeListener,

  getQueryOutput,
  setQueryOutput,
  addQueryOutputChangeListener,

  getShowAdvancedOptions,
  setShowAdvancedOptions,
  addShowAdvancedOptionsChangeListener,
};

  return module.exports;
})();

modules['src/views/queryFormatter/QueryFormatter.js'] = (() => {
  const module = { exports: {} };
  const QueryInput = include('src/components/queryInput/QueryInput.js');
const Code = include('src/components/code/Code.js');
const TextButton = include('src/components/textButton/TextButton.js');
const { compose, If } = include('src/libs/simpleHTML/SimpleHTML.js');
const {
  getQueryInput,
  setQueryInput,
  getQueryOutput,
  getShowAdvancedOptions,
  setShowAdvancedOptions,
} = include('src/store/Store.js');

const QueryFormatter = () => {
  const element = compose('div', {}, [
    QueryInput(() => ({
      value: getQueryInput(),
      oninput: ({ target }) => setQueryInput(target.value),
    })),
    TextButton(() => ({
      label: getShowAdvancedOptions()
        ? 'Hide advanced options'
        : 'Show advanced options',
      onclick: () => setShowAdvancedOptions(!getShowAdvancedOptions()),
    })),
    If(
      () => getQueryOutput(),
      () => [Code(() => ({ innerText: getQueryOutput() }))]
    ),
  ]);
  return element;
};

module.exports = QueryFormatter;

  return module.exports;
})();

modules['src/app/App.js'] = (() => {
  const module = { exports: {} };
  const Navigator = include('src/components/navigator/Navigator.js');
const StyleGuide = include('src/views/styleGuide/StyleGuide.js');
const QueryFormatter = include('src/views/queryFormatter/QueryFormatter.js');
const { compose, If } = include('src/libs/simpleHTML/SimpleHTML.js');
const { getCurrentRoute } = include('src/router/Router.js');

const App = () => {
  const element = compose('div', {}, [
    Navigator(() => ({ currentRoute: getCurrentRoute() })),

    compose('div', () => ({}), [
      compose(
        'div',
        { style: 'width: 800px; margin-left: calc(50vw - 400px);' },
        [
          If(
            () => getCurrentRoute() === '/',
            () => [QueryFormatter(() => ({}))]
          ),
          If(
            () => getCurrentRoute() === '/style-guide',
            () => [StyleGuide(() => ({}))]
          ),
        ]
      ),
    ]),
  ]);
  return element;
};

module.exports = App;

  return module.exports;
})();

window.addEventListener('load', () => {
const Observable = include('src/libs/observable/Observable.js');
const App = include('src/app/App.js');
const Store = include('src/store/Store.js');
const Router = include('src/router/Router.js');

const app = App(() => ({}));
Router.addHashChangeListener(app.update);
Store.addQueryInputChangeListener(app.update);
Store.addQueryOutputChangeListener(app.update);
Store.addShowAdvancedOptionsChangeListener(() => {
  console.log('updating'), app.update();
});

Object.assign(document.body.style, {
  fontFamily: 'Sans-Serif',
  margin: '0',
});

document.body.appendChild(app);

})
</script>