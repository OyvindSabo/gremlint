
<script>
const modules = {}
const include = path => modules[path];

modules['src/libs/simpleRouter/SimpleRouter.js'] = (() => {
  const module = { exports: {} };
  function SimpleRouter(routes) {
  /**
   * @param {string} routes
   */
  this.setRoutes = function (routes) {
    Object.entries(routes).forEach(([route, title]) => {
      this.routes[route] = route;
      this.titles[route] = title;
      if (route === '/') {
        this.routes[''] = route;
        this.titles[''] = title;
      }
    });
    this.syncWithHash();
  };
  SimpleRouter.getTokens = function (hash) {
    return hash
      .split('/')
      .filter(Boolean)
      .filter((element) => element !== '#')
      .filter((element) => element !== '#!');
  };
  /**
   * @param {string} token
   * @returns {boolean}
   */
  SimpleRouter.isParameterRouteToken = function (token) {
    if (
      token.indexOf('<') !== 0 ||
      !token.slice(2, -4).includes(':') ||
      token.indexOf('>') !== token.length - 1
    ) {
      return false;
    }
    const [parameter, type] = token
      .slice(token.indexOf('<') + 1, token.indexOf('>'))
      .split(':');

    if (!['int', 'string', 'number'].includes(type)) {
      return false;
    }
    return true;
  };
  SimpleRouter.appendTokenToHash = function (hash, token) {
    return `${hash}/${token}`;
  };
  SimpleRouter.parseParameterRouteToken = function (token) {
    const [parameter, type] = token
      .slice(token.indexOf('<') + 1, token.indexOf('>'))
      .split(':');
    return {
      parameter,
      type,
    };
  };
  // (hash: string, route: string) => false | { [key: string]: number | string }
  SimpleRouter.getMatch = function (hash, route) {
    const hashTokens = SimpleRouter.getTokens(hash);
    const routeTokens = SimpleRouter.getTokens(route);
    const params = {};
    let reconstructedHash = '#!';
    if (hashTokens.length !== routeTokens.length) return false;
    for (let i of Object.keys(hashTokens)) {
      const hashToken = hashTokens[i];
      const routeToken = routeTokens[i];
      if (SimpleRouter.isParameterRouteToken(routeToken)) {
        const { parameter, type } = SimpleRouter.parseParameterRouteToken(
          routeToken
        );
        if (type === 'int') {
          if (!Router.isInt(hashToken)) return false;
          params[parameter] = parseInt(hashToken);
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        } else if (type === 'number' && !Router.isNumber(hasToken)) {
          if (!Router.isNumber(hashToken)) return false;
          params[parameter] = Number(hashToken);
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        } else if (type === 'string') {
          params[parameter] = hashToken;
          reconstructedHash = SimpleRouter.appendTokenToHash(
            reconstructedHash,
            hashToken
          );
        }
      } else {
        if (hashToken !== routeToken) return false;
        reconstructedHash = SimpleRouter.appendTokenToHash(
          reconstructedHash,
          hashToken
        );
      }
    }
    return { params, reconstructedHash };
  };
  SimpleRouter.getRouteAndParamsFromHash = function (hash, routes) {
    for (let route of Object.keys(routes)) {
      const match = SimpleRouter.getMatch(hash, route);
      if (match) {
        const { params, reconstructedHash } = match;
        return { route, params, reconstructedHash };
      }
    }
    return { route: '', params: {}, reconstructedHash: '' };
  };
  /**
   * @param {Object.<string, number | string>} params
   */
  this.setParams = function (params) {
    this.params = params;
    // Todo: Maybe dispatch some kind of event
  };
  this.setCurrentRoute = function (route) {
    this.currentRoute = route;
  };
  this.setCurrentTitle = function (title) {
    this.currentTitle = title;
  };
  SimpleRouter.removeHash = function () {
    return history.replaceState(null, null, ' ');
  };
  this.syncWithHash = function () {
    const { hash } = location;
    const {
      route,
      params,
      reconstructedHash,
    } = SimpleRouter.getRouteAndParamsFromHash(hash, this.routes);
    this.setParams(params);
    this.setCurrentRoute(this.routes[route]);
    this.setCurrentTitle(this.titles[route]);
    if (reconstructedHash === '#!') {
      SimpleRouter.removeHash();
    } else {
      history.replaceState(undefined, undefined, reconstructedHash);
    }
    document.title = this.currentTitle;
  };
  this.params = {};
  this.currentRoute = '';
  this.routes = {};
  this.titles = {};
  this.hashChangeListeners = [];
  this.setRoutes(routes);
  window.addEventListener('hashchange', () => {
    this.syncWithHash();
    this.callHashChangeListeners();
  });
  /**
   * @param {string} route
   * One of the registered routes, without hashbang
   */
  this.navigateTo = (route) => {
    location.hash = `#!${route}`;
  };

  this.refresh = () => this.syncWithHash();

  // @possiblyNumber: string
  SimpleRouter.isNumber = function (possiblyNumber) {
    return !isNaN(Number(possiblyNumber));
  };
  SimpleRouter.isInt = function (possiblyInt) {
    return (
      SimpleRouter.isNumber(possiblyInt) &&
      parseInt(possiblyInt) === Number(possiblyInt)
    );
  };
  this.addHashChangeListener = (callback) => {
    this.hashChangeListeners.push(callback);
    this.callHashChangeListeners();
  };
  this.callHashChangeListeners = () => {
    this.hashChangeListeners.forEach((hashChangeListener) =>
      hashChangeListener({
        params: this.params,
        currentRoute: this.currentRoute,
      })
    );
  };
  this.getParams = () => this.params;
  this.getCurrentTitle = () => this.currentTitle;
  SimpleRouter.isProp = (propsOrChild) =>
    !(propsOrChild instanceof HTMLElement || typeof propsOrChild === 'string');
}

module.exports = SimpleRouter;

  return module.exports;
})();

modules['src/libs/observable/Observable.js'] = (() => {
  const module = { exports: {} };
  class Observable {
  constructor(value) {
    // Maybe this can cause an id collision of two observables created almost at the same time
    this._id = `${Math.random()}${+new Date()}`;
    this._value = value;
  }
  emit() {
    window.dispatchEvent(
      new CustomEvent(this._id, {
        detail: this._value,
      })
    );
  }
  get id() {
    return this._id;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    // Maybe this should do a deep compare in case value is an object?
    if (value === this._value) return;
    this._value = value;
    this.emit();
  }
}

module.exports = Observable;

  return module.exports;
})();

modules['src/libs/fakeReact/FakeReact.js'] = (() => {
  const module = { exports: {} };
  const Observable = include('src/libs/observable/Observable.js');

const createElement$ = (elementType, ...observables) => {
  const element = document.createElement(elementType);
  observables.flat().forEach((observable) => {
    if (
      // If it is observable value
      observable instanceof Observable &&
      ['string', 'number'].includes(typeof observable.value)
    ) {
      const textNode = document.createTextNode(observable.value);
      element.appendChild(textNode);
      window.addEventListener(observable.id, ({ detail }) => {
        textNode.nodeValue = detail;
      });
      return;
    }
    if (
      // If it is non-observable value
      ['string', 'number'].includes(typeof observable)
    ) {
      const textNode = document.createTextNode(observable);
      element.appendChild(textNode);
      return;
    }
    // If it is a dom node
    element.appendChild(observable);
  });
  // Note that styleObject$ is an object with observable values, not an observable object
  // TODO: It should also be possible to set the style as a non-observable object
  element.setStyle = (styleObject$) => {
    Object.entries(styleObject$).forEach(([styleProperty, styleValue$]) => {
      if (styleValue$ instanceof Observable) {
        element.style[styleProperty] = styleValue$.value;
        window.addEventListener(styleValue$.id, ({ detail }) => {
          element.style[styleProperty] = detail;
        });
        return;
      }
      element.style[styleProperty] = styleValue$;
    });
    return element;
  };
  element.setProps = (propsObject) => {
    Object.entries(propsObject).forEach(([propKey, propValue$]) => {
      if (propValue$ instanceof Observable) {
        element[propKey] = propValue$.value;
        window.addEventListener(propValue$.id, ({ detail }) => {
          element[propKey] = detail;
        });
        return;
      }
      element[propKey] = propValue$;
    });
    return element;
  };
  element.onClick = (clickCallback) => {
    element.style.cursor = 'pointer';
    element.onclick = () => clickCallback(element);
    return element;
  };
  element.onMouseEnter = (mouseEnterCallback) => {
    element.onmouseenter = () => mouseEnterCallback(element);
    return element;
  };
  element.onMouseLeave = (mouseLeaveCallback) => {
    element.onmouseleave = () => mouseLeaveCallback(element);
    return element;
  };
  element.onInput = (inputCallback) => {
    element.addEventListener('input', () => inputCallback(element));
    return element;
  };
  return element;
};
const a$ = (...children) => createElement$('a', ...children);
const p$ = (...children) => createElement$('p', ...children);
const button$ = (...children) => createElement$('button', ...children);
const div$ = (...children) => createElement$('div', ...children);
const h1$ = (...children) =>
  createElement$('h1', ...children).setStyle({
    margin: '0',
    fontWeight: 'normal',
  });
const h2$ = (...children) =>
  createElement$('h2', ...children).setStyle({
    margin: '0',
    fontWeight: 'normal',
  });
const h3$ = (...children) =>
  createElement$('h3', ...children).setStyle({
    margin: '0',
    fontWeight: 'normal',
  });
const input$ = (value = '') => createElement$('input').setProps({ value });
const textArea$ = (value = '') =>
  createElement$('textarea').setProps({ value });
const br$ = () => createElement$('br');
const canvas$ = ({ width, height }) => {
  const element = createElement('canvas');
  element.width = width;
  element.height = height;
  return element;
};

module.exports = {
  createElement$,
  a$,
  p$,
  button$,
  div$,
  h1$,
  h2$,
  h3$,
  input$,
  textArea$,
  canvas$,
};

  return module.exports;
})();

modules['src/components/centeredContainer/CenteredContainer.js'] = (() => {
  const module = { exports: {} };
  const { div$ } = include('src/libs/fakeReact/FakeReact.js');

const CenteredContainer = (...chilren) =>
  div$(...chilren).setStyle({
    margin: 'auto',
    maxWidth: '720px',
  });

module.exports = CenteredContainer;

  return module.exports;
})();

modules['src/components/navigatorLink/NavigatorLink.js'] = (() => {
  const module = { exports: {} };
  const { a$ } = include('src/libs/fakeReact/FakeReact.js');

const NavigatorLink = ({ title, to }) =>
  a$(title)
    .setProps({ href: `#!${to}` })
    .setStyle({ marginRight: '20px' });

module.exports = NavigatorLink;

  return module.exports;
})();

modules['src/atomicComponents/padding/Padding.js'] = (() => {
  const module = { exports: {} };
  const { div$ } = include('src/libs/fakeReact/FakeReact.js');

const Padding = (...children) =>
  div$(...children).setStyle({ padding: '10px' });

module.exports = Padding;

  return module.exports;
})();

modules['src/components/navigator/Navigator.js'] = (() => {
  const module = { exports: {} };
  const Padding = include('src/atomicComponents/padding/Padding.js');

const Navigator = Padding;

module.exports = Navigator;

  return module.exports;
})();

modules['src/views/styleGuide/StyleGuide.js'] = (() => {
  const module = { exports: {} };
  const { div$ } = include('src/libs/fakeReact/FakeReact.js');

const StyleGuide = () => div$('Style guide');

module.exports = StyleGuide;

  return module.exports;
})();

modules['src/libs/simpleHTML/SimpleHTML.js'] = (() => {
  const module = { exports: {} };
  const doAddInnerShadow = (element) => {
  element.style.boxShadow = 'inset rgba(0, 0, 0, 0.25) 0 0 10px -5px';
};

const doAddShadow = (element) => {
  element.style.boxShadow = 'rgba(0, 0, 0, 0.25) 0 0 10px -5px';
};

const doPatchChildren = (
  element,
  newChildren,
  compareFunction = (a, b) => a === b
) => {
  newChildren.forEach((newChild, index) => {
    // If the new child node already exists on the correct index, jump to next iteration
    if (compareFunction(newChild, element.childNodes[index])) return;

    // As long as there is an old child node at the current index which does not correspond to any of the new childNodes, remove it
    while (
      element.childNodes[index] &&
      !newChildren.some((newChild) =>
        compareFunction(newChild, element.childNodes[index])
      )
    ) {
      element.removeChild(element.childNodes[index]);
    }

    // Insert the new child node at the correct position
    if (element.childNodes[index]) {
      element.insertBefore(newChild, element.childNodes[index]);
      return;
    }
    // TODO: Find out why this is needed
    if (!(newChild.contains && newChild.contains(element))) {
      element.append(newChild);
    }
    return;
  });

  // Remove any superfluous old nodes which don't correspond to the new nodes
  while (newChildren.length < element.childNodes.length) {
    element.removeChild(element.childNodes[newChildren.length]);
  }
};

const flatten = (items) => {
  const flat = [];

  items.forEach((item) => {
    if (Array.isArray(item)) {
      flat.push(...flatten(item));
    } else {
      flat.push(item);
    }
  });

  return flat;
};

const compose = (elementType, getProps, children) => {
  const element = document.createElement(elementType);

  // Assign props
  if (typeof getProps === 'function') {
    Object.assign(element, getProps());
  } else {
    Object.assign(element, getProps);
  }

  // Append children
  element.append(...flatten(children).filter(Boolean));

  element.update = () => {
    // We update the props only if they are provided as a function. Otherwise they are static.
    if (typeof getProps === 'function') {
      if (element.setSelectionRange) {
        const { selectionStart, selectionEnd } = element;
        element.setSelectionRange(selectionStart, selectionEnd);
      } else {
        Object.assign(element, getProps());
      }
    }

    Array.from(element.childNodes).forEach((childNode) => {
      // We check that the parent node exists because a previous sibling might
      // be a logic element which has unmounted a later element
      if (typeof childNode.update === 'function' && childNode.parentNode) {
        childNode.update();
      }
    });
  };
  return element;
};

const createContentsContainer = () => {
  const element = Object.assign(document.createElement('div'), {
    style: 'display: contents;',
  });
  return element;
};

const Each = (getArray, mappingFunction) => {
  const logicElement = createContentsContainer();
  let array = getArray();
  const childNodes = flatten(
    array.map((_, i) =>
      mappingFunction(
        () => getArray()[i],
        () => i,
        getArray
      )
    )
  );

  logicElement.append(...childNodes);

  logicElement.update = () => {
    const newArray = getArray();

    if (newArray.length === array.length) {
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
      return;
    }

    // If some elements should be added
    if (newArray.length > array.length) {
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });

      const newChildNodes = flatten(
        newArray.slice(array.length).map((_, _i) => {
          const i = _i + array.length;
          return mappingFunction(
            () => getArray()[i],
            () => i,
            getArray
          );
        })
      );

      logicElement.append(...newChildNodes);

      array = newArray;
      return;
    }

    // If some elements should be removed
    if (newArray.length < array.length) {
      // Even if we already have nodes which can be updated to match the new
      // child nodes, we need to see how many nodes we should keep, since each
      // item in the array can potentially be mapped to several nodes.
      const newChildNodes = flatten(
        newArray.map((_, i) =>
          mappingFunction(
            () => getArray()[i],
            () => i,
            getArray
          )
        )
      );

      // Remove superfluous nodes
      const childrenToBeRemoved = Array.from(logicElement.childNodes).slice(
        newChildNodes.length
      );
      childrenToBeRemoved.forEach((childNodeToBeRemoved) => {
        logicElement.removeChild(childNodeToBeRemoved);
      });

      // Update variables
      array = newArray;

      // Update current child nodes
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
    }
  };

  return logicElement;
};

const If = (getCondition, getThenChildNodes, getElseChildNodes = () => []) => {
  const logicElement = createContentsContainer();
  let condition = getCondition();
  const childNodes = condition
    ? flatten(getThenChildNodes()).filter(Boolean)
    : flatten(getElseChildNodes()).filter(Boolean);

  logicElement.append(...childNodes);

  logicElement.update = () => {
    if (condition && getCondition()) {
      Array.from(logicElement.childNodes).forEach((childNode) => {
        if (typeof childNode.update === 'function') {
          childNode.update();
        }
      });
      return;
    }
    if (!condition && getCondition()) {
      condition = true;
      const thenChildNodes = flatten(getThenChildNodes()).filter(Boolean);
      // Remove the old children
      logicElement.innerHTML = '';

      // Add the new children after the logic element
      logicElement.append(...thenChildNodes);
      return;
    }
    if (condition && !getCondition()) {
      condition = false;
      const elseChildNodes = flatten(getElseChildNodes()).filter(Boolean);
      // Remove the old children
      logicElement.innerHTML = '';

      // Add the new children
      logicElement.append(...elseChildNodes);
      return;
    }
  };
  return logicElement;
};

class SimpleHTML {
  static isProp = (propsOrChild) =>
    !(propsOrChild instanceof HTMLElement || typeof propsOrChild === 'string');
  static makeElement(elementType, propsOrChild, ...maybeAllChildren) {
    const element = document.createElement(elementType);
    const hasProps = SimpleHTML.isProp(propsOrChild);
    const props = hasProps ? propsOrChild || {} : {};
    const children = hasProps
      ? maybeAllChildren
      : [propsOrChild, ...maybeAllChildren];
    Object.entries(props).forEach(([attribute, value]) => {
      if (attribute === 'style') {
        Object.assign(element.style, value);
      } else if (attribute === 'onClick') {
        element.onclick = value;
      } else if (attribute === 'onInput') {
        element.oninput = value;
      } else {
        element[attribute] = value;
      }
    });
    children
      .filter(Boolean)
      .map((child) =>
        typeof child === 'string' ? document.createTextNode(child) : child
      )
      .forEach((child) => {
        element.appendChild(child);
      });
    return element;
  }
}

const doMerge = (oldElement, newElement) => {
  if (!oldElement.parentNode) return;

  const oldChildren = Array.from(oldElement.childNodes);
  const newChildren = Array.from(newElement.childNodes);
  newChildren.forEach((newChild, i) => {
    let foundMatchingOldChild = false;
    while (oldChildren.length && !foundMatchingOldChild) {
      oldChild = oldChildren.shift();
      if (
        oldChild.component === newChild.component &&
        oldChild instanceof Element
      ) {
        const selectionStart = oldChild.selectionStart;
        const selectionEnd = oldChild.selectionEnd;
        oldChild.value = newChild.value;
        oldChild.selectionStart = selectionStart;
        oldChild.selectionEnd = selectionEnd;

        oldChild.update(...newChild.propsAndChildren);
        if (Object.keys(newChild.propsAndChildren[0]).includes('style')) {
          if (!oldChild.style) {
            Object.keys(oldChild.parentNode.style).forEach((property) => {
              if (!newChild.propsAndChildren[0].style[property]) {
                oldChild.parentNode.style[property] = null;
              }
            });
            Object.assign(
              oldChild.parentNode.style,
              newChild.propsAndChildren[0].style
            );
          } else {
            Object.keys(oldChild.parentNode.style).forEach((property) => {
              if (!newChild.propsAndChildren[0].style[property]) {
                oldChild.style[property] = null;
              }
            });
            Object.assign(oldChild.style, newChild.propsAndChildren[0].style);
          }
        }
        oldChild.innerText = newChild.innerText;

        foundMatchingOldChild = true;
      } else if (
        !(oldChild instanceof Element) &&
        !(newChild instanceof Element)
      ) {
        if (oldChild.data === newChild.data) {
          foundMatchingOldChild = true;
        } else {
          oldChild.data = newChild.data;
        }
        foundMatchingOldChild = true;
      } else {
        oldElement.removeChild(oldChild);
      }
    }
    if (!foundMatchingOldChild) {
      while (oldElement.childNodes[i]) {
        oldElement.removeChild(oldElement.childNodes[i]);
      }
      oldElement.appendChild(newChild);
    }
  });
  while (newChildren.length < oldElement.childNodes.length) {
    oldElement.removeChild(oldElement.childNodes[newChildren.length]);
  }
};

const defineComponent = (elementFunction) => {
  const component = (...propsAndChildren) => {
    const element = elementFunction(...propsAndChildren);
    element.component = component;
    element.propsAndChildren = propsAndChildren;
    element.update = (...newPropsAndChildren) => {
      element.propsAndChildren = newPropsAndChildren;
      doMerge(element, component(...newPropsAndChildren));
    };
    return element;
  };
  return component;
};

const div = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('div', props, ...children)
);

const span = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('span', props, ...children)
);

const a = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('a', props, ...children)
);

const p = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('p', props, ...children)
);

const h1 = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('h1', props, ...children)
);

const h2 = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('h2', props, ...children)
);

const img = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('img', props, ...children)
);

const form = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('form', props, ...children)
);

const input = defineComponent((props) =>
  SimpleHTML.makeElement('input', props)
);

const textarea = defineComponent((props) =>
  SimpleHTML.makeElement('textarea', props)
);

const br = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('br', props, ...children)
);

const button = defineComponent((props, ...children) =>
  SimpleHTML.makeElement('button', props, ...children)
);
// And so on, fill in more as needed...

module.exports = {
  doMerge,
  compose,
  Each,
  If,
  defineComponent,
  div,
  span,
  a,
  p,
  h1,
  h2,
  img,
  form,
  input,
  textarea,
  br,
  button,
  doAddInnerShadow,
  doAddShadow,
  doPatchChildren,
};

  return module.exports;
})();

modules['src/router/Router.js'] = (() => {
  const module = { exports: {} };
  const SimpleRouter = include('src/libs/simpleRouter/SimpleRouter.js');

const router = new SimpleRouter({
  '/': 'Gremlint - Gremlin query formatter',
  '/style-guide': 'Gremlint - Style guide',
});

const getCurrentRoute = () => router.currentRoute;
const addHashChangeListener = (hashChangeListener) => {
  router.addHashChangeListener(hashChangeListener);
};

module.exports = {
  getCurrentRoute,
  addHashChangeListener,
};

  return module.exports;
})();

modules['src/libs/simpleState/SimpleState.js'] = (() => {
  const module = { exports: {} };
  const simpleState = (initialState) => {
  const state = initialState;
  const stateChangeCallbacks = [];
  const emit = () => {
    stateChangeCallbacks.forEach((stateChangeCallback) => {
      stateChangeCallback({ state, setState });
    });
  };
  const setState = (newState) => {
    Object.assign(state, newState);
    emit();
  };
  const addStateChangeListener = (stateChangeCallback) => {
    const element = { state, setState };
    stateChangeCallbacks.push(stateChangeCallback);
    return element;
  };
  return {
    state,
    setState,
    addStateChangeListener,
  };
};

module.exports = simpleState;

  return module.exports;
})();

modules['src/store/Store.js'] = (() => {
  const module = { exports: {} };
  const simpleState = include('src/libs/simpleState/SimpleState.js');

const { state, setState, addStateChangeListener } = simpleState({
  queryInput: '',
  queryOutput: '',
  currentRoute: '/',
});

const getQueryInput = () => state.queryInput;
const setQueryInput = (queryInput) => setState({ queryInput });

const getQueryOutput = () => state.queryOutput;
const setQueryOutput = (queryOutput) => setState({ queryOutput });

const getCurrentRoute = () => state.currentRoute;
const setCurrentRoute = (currentRoute) => setState({ currentRoute });

module.exports = {
  addStateChangeListener,
  getQueryInput,
  setQueryInput,
  getQueryOutput,
  setQueryOutput,
  getCurrentRoute,
  setCurrentRoute,
};

  return module.exports;
})();

modules['src/components/queryOutput/QueryOutput.js'] = (() => {
  const module = { exports: {} };
  const { div$ } = include('src/libs/fakeReact/FakeReact.js');

const QueryOutput = (...children) =>
  div$(...children).setStyle({
    fontFamily: '"Courier New", Courier, monospace',
    whiteSpace: 'pre-wrap',
    borderRadius: '5px',
    padding: '10px',
  });

module.exports = QueryOutput;

  return module.exports;
})();

modules['src/libs/gremlint/Gremlint.js'] = (() => {
  const module = { exports: {} };
  const pipe = value => (...fns) => fns.reduce((value, fn) => fn(value), value);

const formatQuery = (query, config = { maxLineLength: 80 }) => pipe(query)();

module.exports = {
  formatQuery,
};

  return module.exports;
})();

modules['src/views/testCases/TestCases.js'] = (() => {
  const module = { exports: {} };
  const { div$ } = include('src/libs/fakeReact/FakeReact.js');
const QueryOutput = include('src/components/queryOutput/QueryOutput.js');
const { formatQuery } = include('src/libs/gremlint/Gremlint.js');

const testCases = [`g.V().hasLabel('application')`, `g.V().limit(10)`];
const TestCases = ({ state }) =>
  div$(
    ...testCases.map((query) => {
      const formattedQuery = formatQuery(query);
      return div$(
        QueryOutput(query).setStyle({
          background: formattedQuery === query ? 'lightgreen' : 'lightpink',
        }),
        QueryOutput(formattedQuery)
      ).setStyle({
        marginBottom: '20px',
      });
    })
  );

module.exports = TestCases;

  return module.exports;
})();

modules['src/libs/simpleColorPalette/SimpleColorPalette.js'] = (() => {
  const module = { exports: {} };
  const TextColor = 'slategray';
const HighlightedTextColor = 'darkslategray';
const DisabledTextColor = 'lightgray';
const HighlightColor = 'yellowgreen';

module.exports = {
  TextColor,
  HighlightedTextColor,
  DisabledTextColor,
  HighlightColor,
};

  return module.exports;
})();

modules['src/components/navigationButton/NavigationButton.js'] = (() => {
  const module = { exports: {} };
  const { compose } = include('src/libs/simpleHTML/SimpleHTML.js');
const { HighlightedTextColor, TextColor, HighlightColor } = include(
  'src/libs/simpleColorPalette/SimpleColorPalette.js'
);

const NavigationButton = (getProps) => {
  let isHovered = false;

  const getIsHovered = () => isHovered;
  const setIsHovered = (value) => {
    isHovered = value;
    element.update();
  };

  const getIsSelected = () => getProps().isSelected;
  const getHref = () => getProps().href;
  const getLabel = () => getProps().label;

  const getSpanStyle = () => `
    display: inline-block;
    text-align: center;
    box-sizing: border-box;
    width: 160px;
    height: 40px;
    line-height: 40px;
    font-size: 15px;
    border-bottom: ${getIsSelected() ? `2px solid ${HighlightColor}` : 'none'};
  `;

  const getAStyle = () => `
    text-decoration: none;
    display: inline-block;
    width: 100%;
    color: ${
      getIsSelected() || getIsHovered() ? HighlightedTextColor : TextColor
    };
  `;

  const element = compose('span', () => ({ style: getSpanStyle() }), [
    compose(
      'a',
      () => ({
        href: getHref(),
        innerText: getLabel(),
        style: getAStyle(),
        onmouseenter: () => setIsHovered(true),
        onmouseleave: () => setIsHovered(false),
      }),
      []
    ),
  ]);

  return element;
};

module.exports = NavigationButton;

  return module.exports;
})();

modules['src/components/queryInput/atoms.js'] = (() => {
  const module = { exports: {} };
  const { textArea$ } = include('src/libs/fakeReact/FakeReact.js');

const ExpandableTextArea = (value) =>
  textArea$(value).onInput((textArea) => {
    const previousClientHeight = textArea.clientHeight;
    const { scrollX, scrollY } = window;
    textArea.setStyle({ height: 'auto' });
    textArea.setStyle({ height: `${textArea.scrollHeight}px` });
    const newClientHeight = textArea.clientHeight;
    const scrollChange = newClientHeight - previousClientHeight;
    window.scrollTo(scrollX, scrollY + scrollChange);
  });

module.exports = {
  ExpandableTextArea,
};

  return module.exports;
})();

modules['src/components/queryInput/QueryInput.js'] = (() => {
  const module = { exports: {} };
  const { ExpandableTextArea } = include('src/components/queryInput/atoms.js');

const QueryInput = value =>
  ExpandableTextArea(value).setStyle({
    borderRadius: '5px',
    fontFamily: '"Courier New", Courier, monospace',
    background: 'whiteSmoke',
    minHeight: '10em',
    overflow: 'hidden',
    outline: 'none',
    padding: '10px',
    border: 'none',
    resize: 'none',
    width: '100%',
  });

module.exports = QueryInput;

  return module.exports;
})();

modules['src/views/queryFormatter/QueryFormatter.js'] = (() => {
  const module = { exports: {} };
  const { div$ } = include('src/libs/fakeReact/FakeReact.js');
const QueryInput = include('src/components/queryInput/QueryInput.js');
const QueryOutput = include('src/components/queryOutput/QueryOutput.js');
const { formatQuery } = include('src/libs/gremlint/Gremlint.js');

const QueryFormatter = ({ state }) =>
  div$(
    QueryInput(state.queryInput$).onInput(({ value }) => {
      state.queryInput$.value = value;
      state.queryOutput$.value = formatQuery(value);
    }),
    QueryOutput(state.queryOutput$)
  );

module.exports = QueryFormatter;

  return module.exports;
})();

modules['src/app/App.js'] = (() => {
  const module = { exports: {} };
  /*const Observable = include('src/libs/observable/Observable.js');

// Currently needs at least two arguments
const add$ = (...observables) => {
  const sum = observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .reduce((a, b) => a + b);
  const sum$ = new Observable(sum);
  observables.forEach((observable) => {
    window.addEventListener(observable.id, ({ detail }) => {
      const sum = observables
        .map((observable) =>
          observable instanceof Observable ? observable.value : observable
        )
        .reduce((a, b) => a + b);
      sum$.value = sum;
    });
  });
  return sum$;
};

// Currently needs at least two arguments
const subtract$ = (...observables) => {
  const difference = observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .reduce((a, b) => a - b);
  const difference$ = new Observable(difference);
  observables.forEach((observable) => {
    window.addEventListener(observable.id, ({ detail }) => {
      const difference = observables
        .map((observable) =>
          observable instanceof Observable ? observable.value : observable
        )
        .reduce((a, b) => a - b);
      difference$.value = difference;
    });
  });
  return difference$;
};

// Currently needs at least two arguments
const multiply$ = (...observables) => {
  const product = observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .reduce((a, b) => a * b);
  const product$ = new Observable(product);
  observables.forEach((observable) => {
    window.addEventListener(observable.id, ({ detail }) => {
      const product = observables
        .map((observable) =>
          observable instanceof Observable ? observable.value : observable
        )
        .reduce((a, b) => a * b);
      product$.value = product;
    });
  });
  return product$;
};

// Currently needs at least two arguments
const divide$ = (...observables) => {
  const quotient = observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .reduce((a, b) => a / b);
  const quotient$ = new Observable(quotient);
  observables.forEach((observable) => {
    window.addEventListener(observable.id, ({ detail }) => {
      const quotient = observables
        .map((observable) =>
          observable instanceof Observable ? observable.value : observable
        )
        .reduce((a, b) => a / b);
      quotient$.value = quotient;
    });
  });
  return quotient$;
};

const choose$ = (observable, option1, option2) => {
  const result$ = new Observable(
    (observable instanceof Observable ? observable.value : observable)
      ? option1 instanceof Observable
        ? option1.value
        : option1
      : option2 instanceof Observable
      ? option2.value
      : option2
  );
  [observable, option1, option2]
    .filter((observable) => observable instanceof Observable)
    .forEach((observable) => {
      window.addEventListener(observable.id, ({ detail }) => {
        // TODO: Make it possible to set a specific child of an observable
        result$.value = (
          observable instanceof Observable ? observable.value : observable
        )
          ? option1 instanceof Observable
            ? option1.value
            : option1
          : option2 instanceof Observable
          ? option2.value
          : option2;
      });
    });
  return result$;
};

const eq$ = (...observables) => {
  const equality = observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .every((element, _, array) => element === array[0]);
  const equality$ = new Observable(equality);
  observables
    .filter((observable) => observable instanceof Observable)
    .forEach((observable) => {
      window.addEventListener(observable.id, ({ detail }) => {
        const equality = observables
          .map((observable) =>
            observable instanceof Observable ? observable.value : observable
          )
          .every((element, _, array) => element === array[0]);
        equality$.value = equality;
      });
    });
  return equality$;
};

const neq$ = (...observables) => {
  const inequality = !observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .every((element, _, array) => element === array[0]);
  const inequality$ = new Observable(inequality);
  observables
    .filter((observable) => observable instanceof Observable)
    .forEach((observable) => {
      window.addEventListener(observable.id, ({ detail }) => {
        const inequality = !observables
          .map((observable) =>
            observable instanceof Observable ? observable.value : observable
          )
          .every((element, _, array) => element === array[0]);
        inequality$.value = inequality;
      });
    });
  return inequality$;
};

const gt$ = (value1$, value2$) => {
  const value1 = value1$ instanceof Observable ? value1$.value : value1$;
  const value2 = value2$ instanceof Observable ? value2$.value : value2$;

  const isGreaterThan$ = new Observable(value1 > value2);

  [value1$, value2$]
    .filter((observable) => observable instanceof Observable)
    .forEach((observable) => {
      window.addEventListener(observable.id, ({ detail }) => {
        const value1 = value1$ instanceof Observable ? value1$.value : value1$;
        const value2 = value2$ instanceof Observable ? value2$.value : value2$;

        isGreaterThan$.value = value1 > value2;
      });
    });
  return isGreaterThan$;
};

const lt$ = (value1$, value2$) => {
  const value1 = value1$ instanceof Observable ? value1$.value : value1$;
  const value2 = value2$ instanceof Observable ? value2$.value : value2$;

  const isLessThan$ = new Observable(value1 < value2);

  [value1$, value2$]
    .filter((observable) => observable instanceof Observable)
    .forEach((observable) => {
      window.addEventListener(observable.id, ({ detail }) => {
        const value1 = value1$ instanceof Observable ? value1$.value : value1$;
        const value2 = value2$ instanceof Observable ? value2$.value : value2$;

        isLessThan$.value = value1 < value2;
      });
    });
  return isLessThan$;
};

const not$ = (observable) => {
  const conditional =
    observable instanceof Observable ? observable.value : observable;
  const opposite$ = new Observable(!conditional);
  if (observable instanceof Observable) {
    window.addEventListener(observable.id, ({ detail }) => {
      opposite$.value = !detail;
    });
  }
  return opposite$;
};

const or$ = (...observables) => {
  const someTruthy = observables
    .map((observable) =>
      observable instanceof Observable ? observable.value : observable
    )
    .some(Boolean);
  const someTruthy$ = new Observable(someTruthy);
  observables.forEach((observable) => {
    window.addEventListener(observable.id, ({ detail }) => {
      const someTruthy = observables
        .map((observable) =>
          observable instanceof Observable ? observable.value : observable
        )
        .some(Boolean);
      someTruthy$.value = someTruthy;
    });
  });
  return someTruthy$;
};

const slice$ = (stringOrArray$, start$, stop$) => {
  const stringOrArray =
    stringOrArray$ instanceof Observable
      ? stringOrArray$.value
      : stringOrArray$;
  const start = start$ instanceof Observable ? start$.value : start$;
  const stop = stop$ instanceof Observable ? stop$.value : stop$;
  const slicedStringOrArray$ = new Observable(stringOrArray.slice(start, stop));
  [stringOrArray$, start$, stop$]
    .filter((observable) => observable instanceof Observable)
    .forEach((observable) => {
      window.addEventListener(observable.id, ({ detail }) => {
        const stringOrArray =
          stringOrArray$ instanceof Observable
            ? stringOrArray$.value
            : stringOrArray$;
        const start = start$ instanceof Observable ? start$.value : start$;
        const stop = stop$ instanceof Observable ? stop$.value : stop$;
        slicedStringOrArray$.value = stringOrArray.slice(start, stop);
      });
    });
  return slicedStringOrArray$;
};

const split$ = (string$, separator$) => {
  const string = string$ instanceof Observable ? string$.value : string$;
  const separator =
    separator$ instanceof Observable ? separator$.value : separator$;
  const splitString$ = new Observable(string.split(separator));
  [string$, separator$]
    .filter((observable) => observable instanceof Observable)
    .forEach((observable) => {
      window.addEventListener(observable.id, ({ detail }) => {
        const string = string$ instanceof Observable ? string$.value : string$;
        const separator =
          separator$ instanceof Observable ? separator$.value : separator$;
        splitString$.value = string.split(separator);
      });
    });
  return splitString$;
};

const join$ = (array$, separator$) => {
  const array = array$ instanceof Observable ? array$.value : array$;
  const separator =
    separator$ instanceof Observable ? separator$.value : separator$;
  const joinedArray$ = new Observable(array.join(separator));
  [array$, separator$]
    .filter((observable) => observable instanceof Observable)
    .forEach((observable) => {
      window.addEventListener(observable.id, ({ detail }) => {
        const array = array$ instanceof Observable ? array$.value : array$;
        const separator =
          separator$ instanceof Observable ? separator$.value : separator$;
        joinedArray$.value = array.join(separator);
      });
    });
  return joinedArray$;
};

const length$ = (stringOrArray$) => {
  const stringOrArray =
    stringOrArray$ instanceof Observable
      ? stringOrArray$.value
      : stringOrArray$;

  const length$ = new Observable(stringOrArray.length);
  if (stringOrArray$ instanceof Observable) {
    window.addEventListener(stringOrArray$.id, ({ detail }) => {
      length$.value = detail.length;
    });
  }
  return length$;
};

// This is not used and can probably be removed
const toArray$ = (...observables) => {
  const observableArray = observables.map(({ value }) => value);
  const array$ = new Observable(observableArray);
  observables.forEach((observable, i) => {
    window.addEventListener(observable.id, ({ detail }) => {
      // TODO: Make it possible to set a specific child of an observable
      array$.value = observables.map(({ value }) => value);
    });
  });
  return array$;
};

const Choose$ = (observable, element1, element2) => {
  let element = (
    observable instanceof Observable ? observable.value : observable
  )
    ? element1
    : element2;
  if (observable instanceof Observable) {
    window.addEventListener(observable.id, ({ detail }) => {
      // TODO: Make it possible to set a specific child of an observable
      newElement = (
        observable instanceof Observable ? observable.value : observable
      )
        ? element1
        : element2;

      if (newElement !== element) {
        element.parentNode.replaceChild(newElement, element);
        element = newElement;
      }
    });
  }
  return element;
};

const Switch$ = (statement$) => (...clauses) => {
  const cases = clauses.filter((_, i) => i % 2 === 0);
  const elements = clauses.filter((_, i) => i % 2 !== 0);
  return cases.map((theCase, i) => {
    const element = elements[i];
    const display = element.style.display;
    return element.setStyle({
      display: choose$(eq$(statement$, theCase), display, 'none'),
    });
  });
};

const Nothing$ = () => div$().setStyle({ display: 'none' });

const If$ = (observable, element) => Choose$(observable, element, Nothing$());

const { div$ } = include('src/libs/fakeReact/FakeReact.js');

const CenteredContainer = include(
  'src/components/centeredContainer/CenteredContainer.js'
);
const Navigator = include('src/components/navigator/Navigator.js');
const NavigatorLink = include('src/components/navigatorLink/NavigatorLink.js');
const Padding = include('src/atomicComponents/padding/Padding.js');
const QueryFormatter = include('src/views/queryFormatter/QueryFormatter.js');
const StyleGuide = include('src/views/styleGuide/StyleGuide.js');
const TestCases = include('src/views/testCases/TestCases.js');

const App = ({ state, currentRoute$ }) =>
  CenteredContainer(
    Navigator(
      NavigatorLink({ title: 'Query formatter', to: '/' }),
      NavigatorLink({ title: 'Style guide', to: '/style-guide' }),
      NavigatorLink({ title: 'Test cases', to: '/test-cases' })
    ),
    Padding(
      Switch$(currentRoute$)(
        '/',
        QueryFormatter({ state }),
        '/style-guide',
        StyleGuide(),
        '/test-cases',
        TestCases({ state })
      )
    )
  );*/

const NavigationButton = include(
  'src/components/navigationButton/NavigationButton.js'
);
const { compose } = include('src/libs/simpleHTML/SimpleHTML.js');
const { addHashChangeListener, getCurrentRoute } = include(
  'src/router/Router.js'
);

const EnhancedNavigationButton = (getProps) => {
  const element = NavigationButton(getProps);
  addHashChangeListener(() => element.update());
  return element;
};

const getQueryFormatterButtonProps = () => ({
  isSelected: getCurrentRoute() === '/',
  label: 'Query formatter',
  href: '#!/',
});

const getStyleGuideButtonProps = () => ({
  isSelected: getCurrentRoute() === '/style-guide',
  label: 'Style guide',
  href: '#!/style-guide',
});

const App = (getProps) => {
  const element = compose('div', { style: 'width: 800px; margin: auto;' }, [
    compose('div', { style: 'height: 40px' }, [
      EnhancedNavigationButton(getQueryFormatterButtonProps),
      EnhancedNavigationButton(getStyleGuideButtonProps),
    ]),
  ]);
  return element;
};

module.exports = App;

  return module.exports;
})();

window.addEventListener('load', () => {
const SimpleRouter = include('src/libs/simpleRouter/SimpleRouter.js');
const Observable = include('src/libs/observable/Observable.js');
const App = include('src/app/App.js');
const Store = include('src/store/Store.js');

const router = new SimpleRouter({
  '/': 'Gremlint - Gremlin query formatter',
  '/style-guide': 'Gremlint - Style guide',
});

const app = App(() => ({}));

Object.assign(document.body.style, {
  fontFamily: 'Sans-Serif',
  margin: '0px',
});

document.body.appendChild(app);

})
</script>